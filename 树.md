# æ ‘

## [è¾¹æƒé‡å‡ç­‰æŸ¥è¯¢]([2846. è¾¹æƒé‡å‡ç­‰æŸ¥è¯¢ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/minimum-edge-weight-equilibrium-queries-in-a-tree/description/))

**éš¾åº¦ï¼š** ä¸­ç­‰
**æ ‡ç­¾ï¼š** æ ‘ã€LCAã€å€å¢ã€è·¯å¾„è®¡æ•°

------

### é¢˜æ„å›é¡¾

- ç»™ä¸€æ£µå¸¦æƒæ ‘ `edges[i] = [u, v, w]`ï¼Œå…¶ä¸­ `1 â‰¤ w â‰¤ 26`
- å¯¹æ¯æ¡æŸ¥è¯¢ `[a, b]`ï¼šä½ å¯ä»¥ä»»æ„ä¿®æ”¹ *a â†’ b* è·¯å¾„ä¸Šè‹¥å¹²æ¡è¾¹çš„æƒå€¼ï¼Œä½¿è¿™æ¡è·¯å¾„ **æ‰€æœ‰è¾¹æƒéƒ½ç›¸ç­‰**
- æ±‚æœ€å°‘ä¿®æ”¹æ¬¡æ•°

> è‹¥è·¯å¾„é•¿ `len`ï¼Œä»¤ `cnt_max` ä¸ºè·¯å¾„ä¸Š**å‡ºç°æ¬¡æ•°æœ€å¤š**çš„æƒå€¼çš„å‡ºç°æ¬¡æ•°ï¼Œåˆ™æœ€å°‘ä¿®æ”¹
>
> $ops=â€…â€Šlenâ€…â€Šâˆ’â€…â€Šcnt\_max$

------

### æ ¸å¿ƒï¼šåœ¨ LCA å€å¢è¡¨é‡Œå†ç»´æŠ¤ä¸€ä»½ â€œæƒå€¼å‡ºç°æ¬¡æ•°â€

#### 1. è®¡æ•°æ•°ç»„ `cnt_[v][j]` çš„**å«ä¹‰**

- `cnt_[v][j]` æ˜¯ä¸€ä¸ª `Counter`ï¼Œè®°å½• **ä»èŠ‚ç‚¹ `v` å¾€ä¸Šèµ° `2^j` æ¡è¾¹** è¿™æ®µé“¾ä¸Šï¼Œ
   26 ç§æƒå€¼å„å‡ºç°äº†å¤šå°‘æ¬¡

- > **`cnt_[v][j][w]` è¡¨ç¤ºä»èŠ‚ç‚¹ `v` å‡ºå‘ï¼Œå‘ä¸Šè·³ `2^j` æ¡è¾¹ï¼Œç»è¿‡çš„è·¯å¾„ä¸­ï¼Œæƒå€¼ä¸º `w` çš„è¾¹å‡ºç°äº†å¤šå°‘æ¬¡**ã€‚

#### 2. åˆå§‹åŒ– â€”â€” `j = 0`

```python
for y, w in g[x]:          # x æ˜¯çˆ¶ç»“ç‚¹ï¼Œy æ˜¯å„¿å­
    pa[y][0]   = x         # 2^0 = 1 æ­¥ç¥–å…ˆ
    cnt_[y][0][w] = 1      # y â†” x è¿™æ¡è¾¹æƒå€¼ w å‡ºç° 1 æ¬¡
```

- æ ¹èŠ‚ç‚¹æ²¡æœ‰çˆ¶è¾¹ï¼Œæ•… `cnt_[root][0]` å…¨ 0ã€`pa[root][0] = -1`

------

#### 3. å€å¢é€’æ¨å…¬å¼

> â€œé•¿åº¦ 2^(j+1) = å‰ 2^j + å 2^jâ€

```python
mid = pa[v][j]             # å…ˆè·³ 2^j
up[v][j+1] = pa[mid][j]    # å†è·³ 2^j

cnt_[v][j+1] = cnt_[v][j]  +  cnt_[mid][j]    # ä¸¤æ®µé“¾è®¡æ•°ç›¸åŠ 
```

- è¿™æ · `cnt_[v][j]` æ°¸è¿œå’Œ `up[v][j]` **é…å¥—**
- ç©ºé“¾çˆ¶èŠ‚ç‚¹ `mid == -1` ä¸åšæ›´æ–°

------

#### 4. è·³é“¾åŒæ—¶æ”¶é›†è®¡æ•° â€”â€” `get_kth_ancestor`

```python
for i in range(k.bit_length()):
    if k >> i & 1:                     # éœ€è¦èµ° 2^i è¿™æ®µ
        cnt_agg += cnt_[node][i]       # æŠŠè¿™æ®µé“¾çš„è®¡æ•°ç´¯åŠ åˆ°ä¸´æ—¶åŒ…
        node      = pa[node][i]        # çœŸæ­£è·³ä¸Šå»
```

- `cnt_agg` æ˜¯ä¸€è·¯ç´¯åŠ å™¨ï¼›æŸ¥è¯¢ç»“æŸåå°±æ˜¯ *a â†’ b* è·¯å¾„çš„ **æƒå€¼ç›´æ–¹å›¾**

------

#### 5. æ±‚ LCA æ—¶æ€ä¹ˆåŠ è®¡æ•°ï¼Ÿ

1. **æ·±åº¦å¯¹é½**
   - æŠŠè¾ƒæ·±çš„èŠ‚ç‚¹å¾€ä¸Šè·³åˆ°åŒæ·±åº¦ï¼Œè®¡æ•°ç´¯åŠ 
2. **åŒæŒ‡é’ˆä¸€èµ·è·³**
   - å€å¢ä»é«˜åˆ°ä½ï¼šè‹¥ `up[a][i] != up[b][i]`
     - æŠŠ `cnt_[a][i]`ã€`cnt_[b][i]` éƒ½åŠ åˆ°ç´¯åŠ å™¨
     - èŠ‚ç‚¹å„è‡ªä¸Šè·³ `2^i`
3. **æœ€åä¸€æ­¥**
   - å†æŠŠ `a â†’ parent` ä¸ `b â†’ parent` è¿™ä¸¤æ¡ `2^0` è¾¹çš„è®¡æ•°åŠ è¿›æ¥
   - å®ƒä»¬çš„å…¬å…±çˆ¶äº²å³ LCA

------

#### 6. ä»£ç æ¢³ç†ï¼ˆæ‰¿æ¥ä½ ç»™çš„ç±»ï¼‰

```python
class Std:
    class LCA:
        """Useing TreeAncestor calculate LCA"""

        def __init__(self, edges: List[List[int]]):
            n = len(edges) + 1
            m = n.bit_length()
            g = Arr.graph(n)
            cnt_ = Arr.array2d(Counter, n, m)

            for x, y, w in edges:  # Node indices start from 0
                g[x].append((y, w))
                g[y].append((x, w))

            depth = Arr.array(0, n)
            pa = Arr.array2d(-1, n, m)

            def dfs(x: int, fa: int) -> None:
                """Depth-first search to initialize the ancestor table and depth array."""
                pa[x][0] = fa  # init itself
                for y, w in g[x]:
                    if y != fa:
                        depth[y] = depth[x] + 1
                        cnt_[y][0][w] = 1
                        dfs(y, x)
            dfs(0, -1)

            for i in range(m - 1):
                for x in range(n):
                    p = pa[x][i]  # Get the 2^i-th ancestor of node x
                    if p != -1:
                        pp = pa[p][i]  # Get the 2^i-th ancestor of p, which will be the 2^(i+1)-th ancestor of x
                        pa[x][i + 1] = pp  # Set the 2^(i+1)-th ancestor of x
                        cnt_[x][i + 1] = cnt_[x][i] + cnt_[p][i]
            self.depth = depth
            self.pa = pa
            self.cnt_ = cnt_

        def get_kth_ancestor(self, node: int, k: int, cnt_: Counter) -> int:
            """Returns the k-th ancestor of the given node (The starting node). That is, jump up k steps"""
            for i in range(k.bit_length()):
                if (k >> i) & 1:
                    node_new = self.pa[node][i]
                    cnt_ += self.cnt_[node][i]
                    node = node_new
            return node

        def get_lca(self, x: int, y: int):
            """Returns the Lowest Common Ancestor (LCA) of nodes x and y."""
            cnt_ = Counter()
            if self.depth[x] > self.depth[y]:
                x, y = y, x
            # Bring y and x to the same depth
            y = self.get_kth_ancestor(y, self.depth[y] - self.depth[x], cnt_)
            if y == x:
                return x, max(cnt_.values()) if cnt_ else 0
            for i in range(len(self.pa[x]) - 1, -1, -1):
                px, py = self.pa[x][i], self.pa[y][i]
                if px != py:
                    cnt_ += self.cnt_[x][i]
                    cnt_ += self.cnt_[y][i]
                    x, y = px, py  # Move both nodes up by 2^i steps

            cnt_ += self.cnt_[x][0]
            cnt_ += self.cnt_[y][0]
            return self.pa[x][0], max(cnt_.values()) if cnt_ else 0  # Return the parent of x (or y) as LCA


# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Division line â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
class Solution:
    def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:
        lca = Std.LCA(edges)
        ans = []
        for a, b in queries:
            path_len = lca.depth[a] + lca.depth[b]
            lca_ans, max_len = lca.get_lca(a, b)
            path_len -= lca.depth[lca_ans] * 2
            ans.append(path_len - max_len)
        return ans
```

> **å…³é”®ä»…ä¸¤è¡Œï¼š**
>
> - `cnt_[child][0][w] = 1` â€”â€” â€œä¸€æ¡è¾¹â€
> - `cnt_[v][j+1] = cnt_[v][j] + cnt_[mid][j]` â€”â€” â€œæ‹¼ä¸¤æ®µâ€

------

#### 7. æ¯æ¬¡æŸ¥è¯¢æµç¨‹

```
cnt_agg = Counter()

â‘  è‹¥æ·±åº¦ä¸åŒï¼Œå…ˆæŠŠæ·±çš„ä¸€ä¾§ä¸Šè·³ Î”depth æ­¥ â†’ ç´¯åŠ è®¡æ•°
â‘¡ è‹¥æ­¤æ—¶ä¸¤ç‚¹å·²ç›¸ç­‰ï¼Œç»“æŸ
â‘¢ å¦åˆ™ä» logâˆ’1 åˆ° 0ï¼š
     if up[a][i] != up[b][i]:
         cnt_agg += cnt_[a][i] + cnt_[b][i]
         a, b = up[a][i], up[b][i]
â‘£ æŠŠæœ€åä¸¤æ¡ 1 æ­¥è¾¹ä¹ŸåŠ ä¸Š
â‘¤ ops = (depth[a]+depth[b]âˆ’2*depth[LCA]) âˆ’ max(cnt_agg.values())
```

------

#### 8. å¤æ‚åº¦

| é˜¶æ®µ     | æ—¶é—´                                  | ç©ºé—´ |
| -------- | ------------------------------------- | ---- |
| é¢„å¤„ç†   | `O(n log n Â· 26)`ï¼ˆCounter å¸¸æ•°ç¨å¤§ï¼‰ | åŒä¸Š |
| å•æ¬¡æŸ¥è¯¢ | `O(log n Â· 26)`                       | â€”    |

æ¢æˆ **26 é•¿åº¦æ•°ç»„** ä¼šå†å¿«ä¸€å€ï¼Œå†…å­˜å‡åŠï¼Œä½†æ€è·¯å®Œå…¨ä¸€è‡´ã€‚



------

## [åœ¨ä¼ çƒæ¸¸æˆä¸­æœ€å¤§åŒ–å‡½æ•°å€¼](https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game/description/)

**éš¾åº¦ï¼š** ä¸­ç­‰åä¸Š
**æ ‡ç­¾ï¼š** å€å¢ã€å›¾ä¸Šè·³è·ƒã€è·¯å¾„å’Œ

------

### é¢˜æ„æ¦‚è¿°

ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°ç»„ `receiver`ï¼Œè¡¨ç¤ºç¼–å·ä¸º $i$ çš„ç©å®¶ä¼šå°†çƒä¼ ç»™ `receiver[i]`ã€‚ä½ éœ€è¦é€‰æ‹©ä¸€ä¸ªèµ·ç‚¹ $x$ï¼Œè®©çƒä» $x$ å¼€å§‹ä¼  $k$ æ¬¡ï¼Œä¼ çƒè·¯å¾„ä¸ºï¼š

$x, \text{receiver}[x], \text{receiver}[\text{receiver}[x]], \ldots$

å®šä¹‰å‡½æ•°ï¼š

$f(x) = x + \text{receiver}[x] + \text{receiver}[\text{receiver}[x]] + \cdots$

å³çƒä¼  $k$ æ¬¡è¿‡ç¨‹ä¸­ **æ‰€æœ‰æ¥è§¦è¿‡çƒçš„äººçš„ç¼–å·ä¹‹å’Œ**ï¼ˆåŒ…æ‹¬é‡å¤ï¼‰ï¼Œè¦æ±‚æœ€å¤§åŒ– $f(x)$ã€‚

------

### è§£é¢˜æ€è·¯

#### æœ¬è´¨æ¨¡å‹

è¿™ä¸ªå›¾æ˜¯ä¸€ä¸ª**æ¯ä¸ªç‚¹åªæœ‰ä¸€ä¸ªå‡ºè¾¹çš„æœ‰å‘å›¾**ï¼Œå¯èƒ½æœ‰ç¯ã€‚ä½ å¯ä»¥è®¤ä¸ºå®ƒæ˜¯â€œå›¾ä¸Šçš„å€å¢é—®é¢˜â€ï¼š

- ç±»ä¼¼äºâ€œæ±‚æ ‘ä¸Šç¬¬ $k$ çº§ç¥–å…ˆâ€
- ä¸åŒç‚¹æ˜¯ï¼š**å›¾ä¸æ˜¯æ ‘ã€æœ‰ç¯ã€è¿˜è¦ç»´æŠ¤è·¯å¾„ä¸Šç¼–å·ä¹‹å’Œ**

------

#### å¦‚ä½•å»ºæ¨¡å€å¢ï¼Ÿ

æˆ‘ä»¬æ„å»ºå¦‚ä¸‹å€å¢æ•°ç»„ `pa[i][j] = (next_node, total_sum)`ï¼š

- `next_node`: ä»èŠ‚ç‚¹ $i$ å‡ºå‘ï¼Œè·³ $2^j$ æ­¥ååˆ°è¾¾çš„èŠ‚ç‚¹
- `total_sum`: ä» $i$ å‡ºå‘ï¼Œè·³ $2^j$ æ­¥è·¯å¾„ä¸­ç»è¿‡çš„æ‰€æœ‰ç¼–å·ä¹‹å’Œ

#### æ³¨æ„å‡ ç‚¹ç‰¹æ®Šå¤„ç†ï¼š

1. **èŠ‚ç‚¹å¯ä»¥ä¼ çƒç»™è‡ªå·±**ï¼Œæ‰€ä»¥è·³æ­¥æ°¸è¿œæœ‰è§£ï¼Œä¸ä¼šæ–­

2. ä¸ç”¨åˆ¤æ–­çˆ¶èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨

3. åˆå§‹åŒ–ï¼š

   ```python
   pa[i][0] = (receiver[i], receiver[i])
   ```

4. > `pa[i][0]` è¡¨ç¤ºä» i è·³ä¸€æ­¥åè®¿é—®çš„èŠ‚ç‚¹ï¼Œè€Œä¸åŒ…æ‹¬èµ·ç‚¹ i è‡ªå·±ã€‚

------

#### æŸ¥è¯¢é˜¶æ®µ

æšä¸¾æ¯ä¸€ä¸ªèµ·ç‚¹ $x$ï¼Œç„¶åå°è¯•è·³ $k$ æ­¥ï¼Œç±»ä¼¼äºã€ŒæŒ‰ä½æšä¸¾ã€ï¼š

- å°† $k$ æ‹†æˆäºŒè¿›åˆ¶è¡¨ç¤ºï¼šå¦‚æœç¬¬ $j$ ä½æ˜¯ 1ï¼Œå°±è·³ $2^j$ æ­¥
- æ¯æ¬¡è·³æ­¥æ—¶ï¼Œå°†è·¯å¾„ä¸Šçš„å’Œç´¯åŠ ä¸Šå»
- è·³å®Œä¹‹åæ›´æ–°æœ€å¤§å€¼

------

### Python å®ç°ï¼ˆå«è§£é‡Šï¼‰

```python
class Std:
    class TreeAncestor:
        def __init__(self, n: int, m: int, parent: List[int]):
            self.n = n
            self.m = m
            # åˆå§‹åŒ–ï¼špa[i][0] = (receiver[i], receiver[i])
            pa = [[(p, p)] + [(-1, -1)] * m for p in parent]
            for j in range(m):
                for i in range(n):
                    p1, s1 = pa[i][j]
                    p2, s2 = pa[p1][j]  # i -> p1 -> p2
                    pa[i][j + 1] = (p2, s1 + s2)
            self.pa = pa


class Solution:
    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:
        m = k.bit_length() - 1
        ta = Std.TreeAncestor(len(receiver), m, receiver)
        ans = 0
        for i in range(ta.n):  # æšä¸¾æ¯ä¸ªèµ·ç‚¹
            node = i
            total = i
            for j in range(ta.m + 1):  # æšä¸¾ k çš„äºŒè¿›åˆ¶ä½
                if (k >> j) & 1:
                    node, s = ta.pa[node][j]
                    total += s
            ans = max(ans, total)
        return ans
```

------

### æ€»ç»“é‡ç‚¹

| å…³é”®ç‚¹     | è¯´æ˜                                                    |
| ---------- | ------------------------------------------------------- |
| å€å¢è·³æ­¥   | ç±»ä¼¼â€œæ ‘ä¸Šè·³ $k$ æ­¥â€ï¼Œä½†å›¾ä¸­æ¯ä¸ªç‚¹åªæœ‰ä¸€ä¸ªå‡ºè¾¹ï¼Œå…è®¸æœ‰ç¯ |
| é™„å¸¦ä¿¡æ¯   | æ¯ä¸€æ­¥é™¤äº†è·³ï¼Œè¿˜è¦ç»´æŠ¤è·¯å¾„ä¸Šç¼–å·ä¹‹å’Œ                    |
| åˆå§‹åŒ–æ–¹å¼ | `pa[i][0] = (receiver[i], receiver[i])`                 |
| æŸ¥è¯¢æ–¹å¼   | æšä¸¾èµ·ç‚¹ï¼Œç”¨ $k$ çš„äºŒè¿›åˆ¶è·³è·ƒç´¯åŠ è·¯å¾„å’Œ                 |
| æ—¶é—´å¤æ‚åº¦ | $O(n \log k)$ï¼Œå…¶ä¸­ $n$ æ˜¯èŠ‚ç‚¹æ•°ï¼Œ$\log k$ æ˜¯è·³æ­¥æ¬¡æ•°   |

****



å¤ªå¥½äº†ï¼ä½ åˆšæ‰æåˆ°â€œå®Œç¾åŒ¹é…æ•°â€è¿™ä¸ªæ¦‚å¿µå…³é”®ç‚¹æŠ“å¾—å¾ˆå¯¹ã€‚é‚£æˆ‘ç°åœ¨å°±æŒ‰ç…§ä½ æŒ‡å®šçš„æ ¼å¼ï¼ŒæŠŠè“æ¡¥æ¯ç¬¬äºŒé¢˜çš„æ€è·¯å®Œæ•´ã€æ¸…æ™°åœ°æ•´ç†å‡ºæ¥ğŸ‘‡

------

## [å¥½è·¯å¾„è¦†ç›–ä¸æœ€å°ç«¯ç‚¹æ¬¡æ•°](https://chatgpt.com/c/6860da64-610c-800e-a8a1-24ae1af8a6bf?model=gpt-4o#)

**éš¾åº¦ï¼š** ä¸­ç­‰åä¸Š

**æ ‡ç­¾ï¼š** æ ‘ã€æ„é€ ã€é…å¯¹è®¡æ•°ã€åŒ¹é…æ•°ã€æ•°å­¦

------

### **é¢˜æ„ä¸æ€è·¯ï¼š**

#### é¢˜ç›®ç®€è¿°

ç»™å®šä¸€æ£µ $n$ ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ¯æ¡è¾¹è¦è¢«**æ°å¥½ä¸€æ¡è·¯å¾„**è¦†ç›–ã€‚æˆ‘ä»¬å®šä¹‰è¿™æ ·çš„è·¯å¾„é›†åˆä¸ºâ€œå¥½é›†åˆâ€ $S$ã€‚

å®šä¹‰ï¼š

- å¯¹æ¯ä¸ªå¥½é›†åˆ $S$ï¼Œè®¾ $f(S) = \max_i$ {èŠ‚ç‚¹ $i$ ä½œä¸ºè·¯å¾„ç«¯ç‚¹å‡ºç°çš„æ¬¡æ•°}ã€‚

ä»»åŠ¡ï¼š

- æ‰¾å‡ºæ‰€æœ‰å¥½é›†åˆä¸­æœ€å°çš„ $f(S)$ å€¼ $M$ï¼Œå¹¶ç»Ÿè®¡æœ‰å¤šå°‘ä¸ªé›†åˆ $S$ æ»¡è¶³ $f(S) = M$ï¼Œå¯¹æ¨¡æ•°å–æ¨¡è¾“å‡ºã€‚

### è§£é¢˜æ€è·¯æ¦‚è§ˆ

#### **Step 1ï¼šæ˜ç¡®æœ€ä¼˜å€¼ $M = 1$**

- æ ‘æ˜¯æ— ç¯å›¾ï¼Œæˆ‘ä»¬è¦ç”¨è‹¥å¹²æ¡**ä¸ç›¸äº¤è·¯å¾„**è¦†ç›–æ‰€æœ‰è¾¹ã€‚
- è‹¥æŸä¸ªèŠ‚ç‚¹åº¦æ•°æ˜¯å¥‡æ•°ï¼Œå°±å¿…é¡»æˆä¸ºæŸæ¡è·¯å¾„çš„ç«¯ç‚¹ï¼ˆå¦åˆ™ä¼šå‰©ä¸‹ä¸€æ¡è¾¹æ²¡æ³•é…ï¼‰ã€‚
- æœ€ä¼˜åšæ³•æ˜¯è®©æ¯ä¸ªèŠ‚ç‚¹**æœ€å¤šä½œä¸ºè·¯å¾„ç«¯ç‚¹å‡ºç°ä¸€æ¬¡**ï¼Œè¿™æ ·å°±å¯ä»¥åšåˆ° $f(S)=1$ã€‚

#### **Step 2ï¼šç­‰ä»·è½¬åŒ–ä¸ºå±€éƒ¨é…å¯¹é—®é¢˜**

æˆ‘ä»¬å‘ç°ï¼Œè¦æ»¡è¶³ $f(S)=1$ï¼Œç­‰ä»·äºï¼š

> **æ¯ä¸ªèŠ‚ç‚¹æŠŠå®ƒçš„ç›¸é‚»è¾¹å°½é‡é…å¯¹ï¼Œåªå…è®¸å‰©ä¸‹ 1 æ¡è¾¹ï¼ˆå¦‚æœæ˜¯å¥‡æ•°åº¦ï¼‰ä½œä¸ºè·¯å¾„ç«¯ç‚¹ï¼Œä¸èƒ½å‰©ä¸‹è¶…è¿‡ 1 æ¡ã€‚**

ä¸¾ä¾‹ï¼š

- å¦‚æœæŸä¸ªç‚¹åº¦æ•°æ˜¯ 4ï¼Œé‚£ä¹ˆå¯ä»¥å°†è¾¹é…æˆ 2 å¯¹ â†’ å®Œç¾åŒ¹é…ï¼›
- å¦‚æœåº¦æ•°æ˜¯ 3ï¼Œåªèƒ½ç•™ä¸‹ 1 æ¡è¾¹ä½œä¸ºè·¯å¾„ç«¯ç‚¹ï¼Œå‰©ä¸‹çš„ 2 æ¡ä¹Ÿè¦é…æˆ 1 å¯¹ã€‚

è¿™ç§â€œæŠŠ incident edges é…å¯¹â€çš„è¿‡ç¨‹ï¼Œç§°ä¸º**å®Œç¾åŒ¹é…æ•°è®¡ç®—**ã€‚

------

#### æ¯ä¸ªèŠ‚ç‚¹çš„é…å¯¹æ–¹æ¡ˆæ•°ï¼ˆå®Œç¾åŒ¹é…æ•°ï¼‰

è®¾æŸä¸ªèŠ‚ç‚¹çš„åº¦æ•°ä¸º $d$ï¼Œåˆ†ä¸¤ç§æƒ…å†µè®¨è®ºï¼š

- **å¶æ•°åº¦ï¼ˆ$d=2m$ï¼‰**
   è¦æŠŠ $2m$ æ¡è¾¹é…æˆ $m$ å¯¹ â‡’ å®Œç¾åŒ¹é…æ•°ä¸ºï¼š

  $g(d) = \frac{(2m)!}{2^m \cdot m!}$

- **å¥‡æ•°åº¦ï¼ˆ$d=2m+1$ï¼‰**
   å¿…é¡»ç•™ä¸‹ 1 æ¡è¾¹ï¼ˆä½œç«¯ç‚¹ï¼‰ï¼Œå†æŠŠå‰©ä¸‹ $2m$ æ¡é…æˆ $m$ å¯¹ â‡’ åŒ¹é…æ•°ä¸ºï¼š

  $g(d) = d \cdot \frac{(2m)!}{2^m \cdot m!} = \frac{d!}{2^m \cdot m!}$

ç»Ÿä¸€å†™æˆå…¬å¼ï¼ˆè®¾ $m = \lfloor d/2 \rfloor$ï¼‰ï¼š

$\boxed{g(d) = \frac{d!}{2^m \cdot m!}}$

------

### å…¨å›¾çš„æ€»æ–¹æ¡ˆæ•°

ç”±äºæ¯ä¸ªç‚¹çš„é…å¯¹æ–¹å¼æ˜¯**ç‹¬ç«‹**çš„ï¼Œ
 æ‰€ä»¥æ‰€æœ‰æ»¡è¶³ $f(S)=1$ çš„å¥½é›†åˆçš„æ€»æ•°ä¸ºï¼š

$\boxed{ \prod_{v \in \text{æ‰€æœ‰ç‚¹}} g(\deg(v)) }$

------

### **ä»£ç ï¼š**

```python
MOD = 10**9 + 7

def prepare_factorials(N, mod):
    """é¢„å¤„ç†é˜¶ä¹˜ã€é€†é˜¶ä¹˜ã€2 çš„é€†å¹‚æ¬¡å¹‚"""
    fac = [1] * (N + 1)
    ifac = [1] * (N + 1)
    pow2inv = [1] * (N + 1)
    
    for i in range(1, N + 1):
        fac[i] = fac[i - 1] * i % mod
    ifac[N] = pow(fac[N], mod - 2, mod)
    for i in range(N - 1, -1, -1):
        ifac[i] = ifac[i + 1] * (i + 1) % mod
    
    inv2 = pow(2, mod - 2, mod)
    for i in range(1, N + 1):
        pow2inv[i] = pow2inv[i - 1] * inv2 % mod
    
    return fac, ifac, pow2inv

def count_good_path_covers(n, edges):
    """
    è¾“å…¥ï¼šn ä¸ªç‚¹çš„æ ‘ï¼Œedges ä¸ºè¾¹åˆ—è¡¨ï¼ˆ0-basedï¼‰
    è¾“å‡ºï¼šæœ€å°ç«¯ç‚¹æ¬¡æ•° Mï¼Œæ–¹æ¡ˆæ•° mod 1e9+7
    """
    if n == 1:
        return 0, 1  # å•èŠ‚ç‚¹ï¼Œæ— è¾¹ï¼Œç©ºé›†åˆå”¯ä¸€

    deg = [0] * n
    for u, v in edges:
        deg[u] += 1
        deg[v] += 1

    max_deg = max(deg)
    fac, ifac, pow2inv = prepare_factorials(max_deg, MOD)

    ans = 1
    for d in deg:
        m = d // 2
        count = fac[d] * pow2inv[m] % MOD * ifac[m] % MOD
        ans = ans * count % MOD

    return 1, ans  # æœ€å° f(S)=1ï¼Œæ–¹æ¡ˆæ•°ä¸º ans
```

------

