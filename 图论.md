# 图论

## [牛奶工厂](https://www.acwing.com/problem/content/description/1473/)

**难度：** 中等

**标签：** 图的遍历、DFS、**Floyd传递闭包**

**题意与思路：**

寻找有向图的“**超级汇点**”。（能被所有点走到的点一定是出度为0的点，可爆搜）。也可floyd传递闭包（传递闭包就是对图的可达性关系的扩展，使得如果存在间接路径 a→b→c，则直接添加一条 a→c 的边。）

## [棋盘覆盖](https://www.acwing.com/problem/content/description/374/)

**难度：** 中等

**标签：** 二分图、匈牙利算法

**题意与思路：**

**棋盘模型转化**：将棋盘的格子视为图中的节点。 如果两个格子相邻且均可放置骨牌，则用一条边连接这两个格子。 问题转化为：在这个图中，找到最大的**二分图匹配**。黑色格子和白色格子分别组成图的两个独立集合 U 和 V。只允许连接黑白格子之间的边。

## [货物运输](https://www.acwing.com/problem/content/4244/)

**难度：** 中等

**标签：** 最短路变种、**最短边的最大值**

**题意与思路：**

**题意：** 给定一个无向图，每条边有最大承载能力，要求从节点 1 到节点 n，找到路径中最小边权最大的路径，计算这条路径的最大承载能力。**解法：** 使用改造的最短路算法，通过优先队列（大根堆）进行松弛操作，不断更新每个节点的最大承载能力。每次松弛时，取当前路径的最小边权作为瓶颈值，选择瓶颈值最大的路径到终点，最终输出最大承载能力

`capacity[neighbor]=max(capacity[neighbor],min(capacity[node],edge weight))`

## [农场派对](https://www.acwing.com/problem/content/description/1134/)

**难度：** 中等

**标签：** 最短路、反向建边

**题意与思路：**

**多对一的最短路≡反向建图一对多的最短路**

## [虫洞](https://www.acwing.com/problem/content/906/)

**难度：** 简单

**标签：** SPFA、负环

**题意与思路：**

是否有负环即可，别忘把所有点都入队（确保算法可以从图的所有节点出发）

## [最短距离](https://www.acwing.com/problem/content/description/1490/)

**难度：** 中等

**标签：** 超级源点、Dijkstra

**题意与思路：**

通过引入一个虚拟的超级源点（编号为$0$），连接所有有商店的村庄，且边权为$0$，问题从 **查询村庄到最近商店的最短距离** 转化为 **超级源点到查询村庄的最短距离**，从而将多源最短路径问题简化为单源最短路径问题。利用Dijkstra算法，从超级源点出发，计算所有村庄到超级源点的最短距离，这一距离即为村庄到最近商店的最短距离。最终，对于每个查询直接返回预先计算的结果即可，算法高效且逻辑清晰。

## [图的最大边权的最小值](https://leetcode.cn/problems/minimize-the-maximum-edge-weight-of-graph/)

**难度：** 困难

**标签：** **逆向思维**、Dijkstra、**最大边权最小的路径**

**题意与思路：**

**前要：**在普通的最短路问题中，“最短路”指的是路径边权和最小的路径。而在这里，“最短路”被重新定义为“**路径中边权最大值最小的路径**”。在路径代价定义为“最大边权”时，贪心扩展的变成了路径中边权的**最大值**，每次找当前能访问到的边权最小的边。

**题意：**题目给定一个由 $n$ 个节点组成的无向图，节点编号为 $0$ 到 $n-1$，图的边由数组 $edges$ 表示，其中每条边为 $(A_i, B_i, W_i)$，表示节点 $A_i$ 和节点 $B_i$ 之间有一条权重为 $W_i$ 的无向边。任务是通过删除一些边，使图满足以下条件：图中所有其他节点必须可以到达节点 $0$。删除边后，图中边的最大权重不超过给定的 $threshold$。每个节点到节点 $0$ 的路径不超过 $threshold$。需要返回满足条件时图的最大边权的最小值。如果无法满足所有条件，返回 $-1$。



**思路：等价转换！！**

把图中的每条边**反向**，那么原问题等价于删边之后：

1. 从 0 出发，必须能访问到所有点。

2. 每个点的**入度**至多为 *threshold*。（一定能满足 *threshold* 的要求。）

   可以从 0 出发，每次走当前能访问到的边中，边权最小的边，这类似 Dijkstra 求最短路（计算路径边权最大值）。更新规则是：新的路径代价为 `max(当前路径的代价, 新的边权)`

也可二分边权+DFS



```python
class Solution:
    def minMaxWeight(self, n: int, edges: List[List[int]], _: int) -> int:
        if len(edges) < n - 1:
            return -1

        g = [[] for _ in range(n)]
        for x, y, w in edges:
            g[y].append((x, w))

        dis = [inf] * n
        dis[0] = 0
        h = [(0, 0)]  # (路径最大边权, 节点编号)
        while h:
            d, x = heappop(h)
            if d > dis[x]:
                continue
            for y, w in g[x]:
                new_d = max(d, w)
                if new_d < dis[y]:
                    dis[y] = new_d
                    heappush(h, (new_d, y))

        ans = max(dis)
        return -1 if ans == inf else ans
```



## [关闭分部的可行集合数目](https://leetcode.cn/problems/number-of-possible-sets-of-closing-branches/description/)

**难度：** 困难

**标签：** Floyd、二进制枚举

**题意与思路：**

**题意：**给定一个公司在全国的 $n$ 个分部以及它们之间的道路信息 $roads$，每条道路由 $[u_i, v_i, w_i]$ 表示连接了 $u_i$ 和 $v_i$ 的一条长度为 $w_i$ 的无向道路。需要关闭一些分部，满足以下条件：

剩余的分部之间必须两两互相连通。

剩余分部的任意两点之间的最远距离不能超过 $maxDistance$。

要求计算满足上述条件的可行关闭方案的数量。



**思路：** Floyd 计算全局最短路径:预处理所有分部之间的最短路径。枚举所有可能的关闭方案，每种方案可以用一个长度为 $n$ 的二进制数表示，$1$ 表示分部保留，$0$ 表示分部关闭。对于每种方案：

过滤掉所有不连通的方案。可以使用 DFS 或 BFS 检查连通性。

对于剩余的连通子图，检查是否所有点对之间的最短路径小于等于 $maxDistance$。



```python
'''
Author: NEFU AB-IN
Date: 2024-07-17 15:46:10
FilePath: \LeetCode\2959\2959.py
LastEditTime: 2024-07-17 16:16:35
'''
# 3.8.19 import
import random
from collections import Counter, defaultdict, deque
from datetime import datetime, timedelta
from functools import lru_cache
from heapq import heapify, heappop, heappush, nlargest, nsmallest
from itertools import combinations, compress, permutations, starmap, tee
from math import ceil, comb, fabs, floor, gcd, log, perm, sqrt
from string import ascii_lowercase, ascii_uppercase
from sys import exit, setrecursionlimit, stdin
from typing import Any, Dict, List, Tuple, TypeVar, Union

# Constants
TYPE = TypeVar('TYPE')
N = int(2e5 + 10)
M = int(20)
INF = int(1e12)
OFFSET = int(100)
MOD = int(1e9 + 7)

# Set recursion limit
setrecursionlimit(int(2e9))


class Arr:
    array = staticmethod(lambda x=0, size=N: [x() if callable(x) else x for _ in range(size)])
    array2d = staticmethod(lambda x=0, rows=N, cols=M: [Arr.array(x, cols) for _ in range(rows)])
    graph = staticmethod(lambda size=N: [[] for _ in range(size)])


class Math:
    max = staticmethod(lambda a, b: a if a > b else b)
    min = staticmethod(lambda a, b: a if a < b else b)


class IO:
    input = staticmethod(lambda: stdin.readline().rstrip("\r\n"))
    read = staticmethod(lambda: map(int, IO.input().split()))
    read_list = staticmethod(lambda: list(IO.read()))


class Std:
    class GraphShortestPath:
        def __init__(self, n: int):
            self.n = n
            self.g = Arr.graph(n)

        def add_edge(self, u: int, v: int, w: int):
            """Add an edge to the graph."""
            self.g[u].append((v, w))

        def floyd(self, exclude_nodes=None) -> List[List[int]]:
            """Floyd's algorithm for finding the shortest paths between all pairs of nodes."""
            if exclude_nodes is None:
                exclude_nodes = []

            dist = Arr.array2d(INF, self.n, self.n)
            # Initialize distances with the given edges
            for u in range(self.n):
                if u in exclude_nodes:
                    continue
                for v, w in self.g[u]:
                    if v in exclude_nodes:
                        continue
                    dist[u][v] = Math.min(dist[u][v], w)

            # Set the diagonal to zero
            for i in range(self.n):
                if i in exclude_nodes:
                    continue
                dist[i][i] = 0

            # Floyd-Warshall algorithm
            for k in range(self.n):
                for i in range(self.n):
                    if dist[i][k] == INF:  # If there is no path from i to k, skip
                        continue
                    for j in range(self.n):
                        if dist[i][j] > dist[i][k] + dist[k][j]:
                            dist[i][j] = dist[i][k] + dist[k][j]

            return dist

# ————————————————————— Division line ——————————————————————


class Solution:
    def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:

        def judge(dist, exclude):
            for u in range(n):
                if u in exclude:
                    continue
                for v in range(n):
                    if v in exclude:
                        continue
                    if dist[u][v] > maxDistance:
                        return 0
            return 1

        graph = Std.GraphShortestPath(n)
        for u, v, w in roads:
            graph.add_edge(u, v, w)
            graph.add_edge(v, u, w)
        ans = 0
        for i in range(1 << n):
            exclude = set()
            for j in range(n):
                if i & 1 << j:
                    exclude.add(j)
            dist = graph.floyd(exclude)
            ans += judge(dist, exclude)

        return ans


Solution().numberOfSets(3, 5, [[0, 1, 2], [1, 2, 10], [0, 2, 10]])

```



****



## 区间和不可表示数计数

**难度：** 中等

**标签：** 数论、图论、最短路、数值半群、Dijkstra

**题意与思路：**

- **题意**
   给定正整数区间 $[L,R]$，区间内的每个整数可以重复使用。问有多少正整数 $x$ **不能** 表示为若干个区间内整数之和；如果这样的 $x$ 无限多，就输出 `"无限个"`。

- **思路**

  1. **特判**

     - 若 $L=1$，面值 1 可生成所有正整数 → 答案 0。
     - 若 $L=R>1$，只有一种面值 $d$，仅 $d$ 的倍数可表示 → 缺失数无限 → 输出 `"无限个"`。

  2. **一般情况**（$R-L\ge1$）

     - 证明区间生成元的公约数为 1，因此“无法表示”的正整数只有**有限**个。

     - 引入 **Apéry 集** 的经典公式：设
       $$
       d = R - L,\quad m = L - 1,\quad m = q\,d + r\;(0\le r<d),
       $$
       

       则**缺失数总个数**（半群的 genus）为
       $$
       g \;=\;\frac{d\,q\,(q+1)}2 \;+\; r\,(q+1).
       $$
       

     - 该公式只需 $O(1)$ 时间整除与乘法运算，即可处理 $L,R$ 高达 $10^9$ 的输入。

------

**代码：**

```python
def count_unrepresentable(L: int, R: int):
    """
    统计区间 [L, R] 生成的正整数半群中，无法表示的正整数个数。
    - L == 1     → 返回 0
    - L == R > 1 → 返回 "无限个"
    - 其它       → 按 Apéry 集公式 O(1) 计算
    """
    if L == 1:
        return 0
    if L == R:
        return "无限个"

    d = R - L
    m = L - 1
    q, r = divmod(m, d)
    # 公式：d*q*(q+1)/2 + r*(q+1)
    return d * q * (q + 1) // 2 + r * (q + 1)
# 示例
print(count_unrepresentable(3, 4))  # → 3（对应缺失 {1,2,5}）
print(count_unrepresentable(2, 3))  # → 1（缺失 {1}）
print(count_unrepresentable(4, 4))  # → "无限个"
```



## 区间和不可表示数计数──同余最短路建模

**难度：** 中等偏上

**标签：** 数论、图论、最短路、完全背包优化

**题意与思路：**

- **题意**
   给定区间 $[L,R]$ 内的整数，每个数可以无限次取用。问有多少正整数 $x$ 无法表示为若干个区间内整数之和。

- **完全背包视角**
   这是一个标准的「完全背包」问题：容量 $x$，物品重量／价值都在 $[L,R]$，判断是否能恰好装满。但当 $x$ 很大（甚至无限）时，普通的 $\mathrm{O}(x\cdot (R-L+1))$ DP 不可行。

- 1. **和对 $L$ 分组**

     - 任何正整数 $x$ 都能写成 $x=kL+r$（$0\le r）。
     - 当我们在凑和时，多取多少个 $L$ 只会让商 $k$ 变化，不影响余数 $r$。
     - 因此，只要知道每个“余数 $r$”能否被凑出，以及最小能凑出的那个和是多少，就能推断出所有不能凑出的数。

  2. **建图＋最短路**

     - **节点**：把余数 $0,1,\dots,L-1$ 当作图的节点。

     - **有向边**：从当前余数 $u$，加一个面值 $c\in[L,R]$ 相当于跳到
       $$
         v = (u + c) \bmod L,
       $$
       并且“花费” $c$。

     - **单源最短路**：从源点 0（代表初始和为 0）跑 Dijkstra，得到每个余数 $r$ 的最短距离 $\mathrm{dist}[r]$。
       $$
         \mathrm{dist}[r] = \min\Bigl\{\text{和}~x : x\equiv r\pmod L, \text{且能被表示}\Bigr\}.
       $$

  3. **统计缺失数**

     - 对每个 $r=1\ldots L-1$，所有形如
        $\;r + tL < \mathrm{dist}[r]$ 的正整数都**凑不出**，数量为
        $\displaystyle\Bigl\lfloor\frac{\mathrm{dist}[r]}{L}\Bigr\rfloor$。
     - 累加即得答案。
     - **关键**：整个过程只和 $L$ 及区间宽度 $(R-L)$ 有关，和要凑出的最大和（完全背包中的“容量”）**无关**，是对完全背包的经典“模 $L$”压缩优化。

> 比如给出[L,R]那就是拿最小的值来做分组，这样余数能少点？
>
> 然后按余数分组，从某个余数u开始连边，边的权值都是[L,R]中的数，v就是u+边权%我们选的基准值建图，我们只关心按余数分组得到的最短距离，也就是最小满足的能凑出来的数，这样别的数的数目，可以通过公式求出来。然后可以发现这个复杂度和刚刚说的完全背包容量没关系。

------

**代码：**

```python
import heapq

def count_unrepresentable_dijkstra(L: int, R: int):
    """
    用单源最短路（Dijkstra）统计区间 [L,R] 生成的正整数半群中
    无法表示的正整数个数。
    """
    # 边界：L=1 全可表示；L=R>1 只有 L 的倍数可表示 → 无穷多
    if L == 1:
        return 0
    if L == R:
        return float('inf')  # 表示“无限个”

    # 构建模 L 状态图并跑 Dijkstra
    mod = L
    dist = [float('inf')] * mod
    dist[0] = 0
    pq = [(0, 0)]  # (当前代价, 余数)

    while pq:
        d, u = heapq.heappop(pq)
        if d > dist[u]:
            continue
        # 枚举所有可用面值 c ∈ [L, R]
        # 权重 c 对应余数跳转 (u + c) % L
        for c in range(L, R + 1):
            v = (u + c) % mod
            nd = d + c
            if nd < dist[v]:
                dist[v] = nd
                heapq.heappush(pq, (nd, v))

    # 统计所有 r=1..L-1 的缺失数
    total = 0
    for r in range(1, mod):
        # 小于 dist[r] 并 ≡ r (mod L) 的数共有 floor(dist[r]/L)
        total += dist[r] // mod

    return total

# --------- 示例 ---------
if __name__ == "__main__":
    print(count_unrepresentable_dijkstra(3, 4))  # → 3
    print(count_unrepresentable_dijkstra(2, 3))  # → 1
    # L=R 的情况，用 float('inf') 表示“无限个”
    print(count_unrepresentable_dijkstra(4, 4))  # → inf
```

> **小结**
>
> - 把「完全背包」状态压缩到 **模 $L$ 的余数图** 上。
> - 节点数仅为 $L$，边数 $O(L\cdot(R-L+1))$，跑一次 Dijkstra 即可得所有最小可表示值。
> - 最后按 $\sum_{r=1}^{L-1}\!\lfloor\mathrm{dist}[r]/L\rfloor$ 统计不可表示数。



****

## [区间和可表示数计数](https://chatgpt.com/c/6860da64-610c-800e-a8a1-24ae1af8a6bf?model=o4-mini-high#)

**难度：** 中等偏上

**标签：** 数论、完全背包优化、最短路、状态压缩

**题意与思路：**

- **题意**
   除了统计“不能凑出的数”，如果再给定一个上限 $X$，如何高效地统计有多少正整数 $1\le x\le X$ **能**被区间 $[L,R]$ 内的数（可重复）凑出？

- **思路**

  1. **跑一次最短路**

     - 同上，把余数状态压缩到节点 $0\ldots L-1$，面值 $c\in[L,R]$ 对应边 $u\to(u+c)\bmod L$，权重 $c$。
     - 从源点 0 运行 Dijkstra，得到每个余数 $r$ 的最小可表示值 $\mathrm{dist}[r]$。

  2. **按余数计数**

     - 对于**非零**余数 $r=1\ldots L-1$：
        最小可表示的是 $\mathrm{dist}[r]$，之后还能表示

       $\mathrm{dist}[r]+L,\;\mathrm{dist}[r]+2L,\;\dots$

       ≤ $X$ 的个数为
       $$
       \bigl\lfloor\frac{X - \mathrm{dist}[r]}{L}\bigr\rfloor + 1  \quad(\text{仅当 }X\ge \mathrm{dist}[r]\,).
       $$

     - 对于**余数 0**：
        正整数里第一次出现是在 $L$，之后是 $2L,3L,\dots$。
        ≤ $X$ 的个数就是 $\lfloor X/L\rfloor$.

  3. **特判**

     - $L=1$：面值 1 可表示所有正整数 → 返回 $X$。
     - $L=R>1$：仅能表示 $L,2L,\dots$ → 返回 $\lfloor X/L\rfloor$.

------

**代码：**

```python
import heapq
from typing import Union

def count_representable(L: int, R: int, X: int) -> Union[int, float]:
    """
    返回 1..X 中有多少个正整数可以表示为 [L,R] 中数字之和（可重复）。
    若可表示无限多（L=1）, 直接返回 X；若值仅为 L 的倍数，返回 floor(X/L)。
    """
    # 特判
    if L == 1:
        return X
    if L == R:
        # 只有 L,2L,3L,... 可以表示
        return X // L

    # 1) Dijkstra on mod-L graph
    mod = L
    dist = [float('inf')] * mod
    dist[0] = 0
    pq = [(0, 0)]  # (累计和, 当前余数)

    while pq:
        d, u = heapq.heappop(pq)
        if d > dist[u]:
            continue
        for c in range(L, R + 1):
            v = (u + c) % mod
            nd = d + c
            if nd < dist[v]:
                dist[v] = nd
                heapq.heappush(pq, (nd, v))

    # 2) 按余数统计可表示数
    total = 0
    # 余数 0
    total += X // L
    # 余数 1..L-1
    for r in range(1, mod):
        d_r = dist[r]
        if d_r <= X:
            # 能表示的数量 = 1（d_r 本身） + floor((X - d_r)/L)
            total += (X - d_r) // L + 1

    return total

# ---------------- 示例 ----------------
if __name__ == "__main__":
    # 区间 [3,4] 内的数，统计 ≤X 能凑出的个数
    for X in range(1, 13):
        print(f"X={X:2d} → {count_representable(3,4,X)}")
    # 对比：凑不出的有 {1,2,5}，所以能凑出的个数 = X -缺失数
```

运行示例输出（区间 $[3,4]$）：

```
X= 1 → 0
X= 2 → 0
X= 3 → 1  # {3}
X= 4 → 2  # {3,4}
X= 5 → 2
X= 6 → 3  # {3,4,6}
X= 7 → 4  # +7
X= 8 → 5  # +8
X= 9 → 6  # +9
X=10 → 7  # +10
X=11 → 8  # +11
X=12 →10  # +12, + (two ways: 4+4+4 or 3+3+3+3 but计为1)
```

> **小结**
>  通过“模 $L$ 的最短路”一次性算出每个余数的最小可表示值，再用除法按余数分桶统计，得到任意上限 $X$ 内的可表示数，时间复杂度 $O(L\,(R-L+1)+L)$，与 $X$ 无关。



****



## [整数倍的最小数位和](https://atcoder.jp/contests/abc077/tasks/arc084_b)（迪杰斯特拉）

**难度：中等**
**标签：** 图论，最短路，Dijkstra，状态压缩，取模

### 题意

给定一个正整数 `k`（2 ≤ k ≤ 10^5），我们要在所有 `k` 的正整数倍 `s` 中，找到一个使得它十进制下各位数字之和最小的 `s`，并输出这个**最小的数位和**。

> 注意：我们不需要输出这个倍数 `s` 本身，只要输出最小的“数位和”。

### 思路详解

#### 1. 为什么能转化为“最短路”？

- 目标是“最小化数字之和”，可以看成在某个状态图中找一条**代价最小**的路径。
- 每“加一个十进制数字 `d`”就像在路径上多走了一条权值为 `d` 的边。

#### 2. 定义状态和边

- **状态** `u`：表示当前构造的数 `s` 对 `k` 取模后的**余数**，也就是 `u = s mod k`。
   总共有 `k` 个状态：0, 1, …, k-1。
- **转移（边）**：
   从状态 `u` “在末尾追加一个数字 `d`”（0 ≤ d ≤ 9）
  - 新数 `s' = s * 10 + d`
  - 新状态 `v = (u * 10 + d) mod k`
  - 边的**权值** = `d`（对数位和的增量）

#### 3. 初始状态（虚拟源点）

- 因为题目要求倍数 `s` 不能以 0 开头，我们不能直接从 `u=0` 追加 `d=0`。
- 我们引入一个“虚拟源点”S，**一次性**向每个 `d` = 1…9 发出一条边：
  - 边 (S → r) 权值 = `d`，其中 `r = d mod k`
- 这相当于选定第一个数字，花费 `d` 的“数位和”。

#### 4. 运行 Dijkstra

- 维护一个长度为 `k` 的数组 `dist[u]` ，表示从 S 到状态 u 的最小“数位和”。

- 初始时，所有 `dist[u] = ∞`，通过第一步将 `d=1…9` 的候选值更新并加入优先队列。

- 依次弹出当前代价最小的 `(cost, u)`，向所有 10 条出边松弛：

  ```text
  for d in 0…9:
      v = (u * 10 + d) % k
      nc = cost + d
      if nc < dist[v]:
          dist[v] = nc
          push (nc, v)
  ```

- 当我们首次“弹出”状态 `u = 0` 时，`dist[0]` 已经是最小可能值，可以**提前结束**。

#### 5. 提前退出示例

- **示例 k=7**

  - 首先初始化：

    ```
    dist[1]=1, dist[2]=2, …, dist[6]=6, dist[0]=7  （分别对应数字 1…9 mod 7）
    ```

  - 弹出 `(1, u=1)`：尝试追加 `d=4`，

    ```
    v = (1*10 + 4) % 7 = 14 % 7 = 0，nc = 1 + 4 = 5 < 7
    ⇒ dist[0] = 5
    ```

    这时队列里再弹出 `(5, 0)`，说明最优数位和是 5，对应的倍数 s=14。

- 最终输出 `5`。

#### 6. 复杂度分析

- 状态数 = k
- 每个状态最多有 10 条出边
- Dijkstra 的时间 ~ O((k + k·10)·log k) ≈ O(k log k)
- 对 k ≤ 10^5 完全可行。

------

### 代码

```python
import sys
import heapq

def solve():
    k = int(sys.stdin.readline())
    INF = 10**18

    # dist[u]: 从“虚拟源”到余数 u 的最小数位和
    dist = [INF] * k
    pq = []

    # 虚拟源 → 首位数字 d（1~9）
    for d in range(1, 10):
        r = d % k
        if d < dist[r]:
            dist[r] = d
            heapq.heappush(pq, (d, r))

    # Dijkstra 主循环
    while pq:
        cost, u = heapq.heappop(pq)
        if cost > dist[u]:
            continue
        # 如果到达余数 0，就得到了最小数位和
        if u == 0:
            print(cost)
            return

        # 追加一位数字 d = 0~9
        for d in range(10):
            v = (u * 10 + d) % k
            nc = cost + d
            if nc < dist[v]:
                dist[v] = nc
                heapq.heappush(pq, (nc, v))

    # 理论上一定能到 0，所以这里不会走到
    print(dist[0])


if __name__ == '__main__':
    solve()
```

> **一句话总结：**
>  把“构造一个 k 倍数”建模为“对余数作图”，在节点 0…k−1 上跑 Dijkstra，边权即“新增数位的值”，首位用虚拟源初始化。



****



## [整数倍的最小数位和](https://atcoder.jp/contests/abc077/tasks/arc084_b) （01BFS）

**标签：** 同余最短路 · 01 BFS · 数论

### 题意与思路：

- **题意**
   给定一个整数 $K$ （$2 \le K \le 10^5$），在所有 **只由 0/1 两种数字组成** 且能被 $K$ 整除的正整数中，求其最小的 **数位和**（即数字 1 出现的最少次数）。只输出这个最少的数位和。

- **建模为图最短路**
   将“拼接十进制数字”过程抽象成「模 $K$ 下的状态转移」：

  - **节点**：当前数字对 $K$ 取模后的 **余数** $r\in[0,K-1]$。

  - **转移（有向边）**：向当前末尾追加一位数字 或者 写 1：+1 取模，权 1

    - 追加 0：

      $r \;\longrightarrow\; (r\times10)\bmod K,\quad\text{边权}=0$

    - 追加 1：

      $r \;\longrightarrow\; (r+1)\bmod K,\quad\text{边权}=1$

  - **起点**：数字必须以 `1` 开头 ⇒ 初始状态

    $r_0 = 1 \bmod K,\qquad\text{初始代价}=1$

  - **目标**：到达余数 0 时，累积的最小代价 即为所求的“最少 1 个数”。

- **算法**
   由于所有边权都在 $\{0,1\}$，可用 **01 BFS**（双端队列版 Dijkstra）：

  - 当沿权 0 边松弛时，用 `appendleft` 入队；
  - 沿权 1 边松弛时，用 `append` 入队。
     这样保证了每次从队列中弹出的节点，其 `dist` 就是最短距离。

- **复杂度**

  - 节点数 $K$，边数 $2K$。
  - 时间 $O(K)$，空间 $O(K)$。
  - 满足 $K\le10^5$ 的要求。

------

### 代码：

```python
import sys
from collections import deque

def min_digit_sum(K: int) -> int:
    INF = 10**18
    dist = [INF] * K
    vis  = [False] * K

    start = 1 % K
    dist[start] = 1
    dq = deque([start])

    while dq:
        u = dq.popleft()
        if vis[u]:
            continue
        vis[u] = True

        # ---- 追加 0：权重 0 ----
        v0 = (u * 10) % K
        if not vis[v0] and dist[v0] > dist[u]:
            dist[v0] = dist[u]
            dq.appendleft(v0)

        # 写 1：+1 取模，权 1
        v1 = (u + 1) % K
        if not vis[v1] and dist[v1] > dist[u] + 1:
            dist[v1] = dist[u] + 1
            dq.append(v1)

    return dist[0]

def main():
    K = int(sys.stdin.readline().strip())
    print(min_digit_sum(K))

if __name__ == "__main__":
    main()
```
