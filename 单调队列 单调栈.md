# 单调队列 单调栈

## 应用场景

### 一、单调队列

#### 1. 典型场景：滑动窗口最值

- **问题**：给定数组和窗口大小 `k`，要求每个长度 `k` 子数组的最小/最大值。
- **解法**：用宽度为 `k` 的单调队列，摊还 O(1) 获取最值，整体 O(n)。

#### 2. 队列优化 DP

- **问题**：形如

  
  $$
  dp[i] = \min_{j < i, j - i \leq K} \{ dp[j] + w(j, i) \} \quad \text{或} \quad dp[i] = \max_{j < i, j - i \leq K} \{ dp[j] + w(j, i) \}
  $$

  其中约束 `i-j <= K` 或者 `j` 在某个区间内。

- **解法**：把 `dp[j] - f(j)` 当成入队值，用单调队列维护最优候选，实现 O(n)。

#### 3. 最短子数组和 ≥ k

- **问题**：找出最短子数组，使得前缀和差值 ≥ `k`。
- **解法**：用单调队列存储“单调递增的前缀和索引”，快速定位最早满足条件的位置。

#### 4. 有界队列或移动平均

- **问题**：实时维护过去 `K` 条记录的最值、中位数、平均等。
- **解法**：单调队列＋“淘汰过期”即可做到 O(1) 更新。

------

### 二、单调栈（Monotonic Stack）

#### 1. “下一个更大/更小元素”问题

- **题型**：对于数组 `arr`，求每个位置右边（或左边）第一个比它大的元素索引/值。
- **解法**：维护递减栈或递增栈，O(n) 一次遍历解决。

#### 2. 直方图最大矩形

- **题型**：求直方图中能形成的最大矩形面积。
- **解法**：两遍单调栈，分别算每根柱子左右“扩张”边界。

#### 3. 股票买卖系列

- **题型**：需要常数时间内知道当前价格左侧最近的某种条件（如更低/更高）的位置。
- **解法**：用单调栈快速定位“上一个最低点”、“下一个更高点”等。

#### 4. 树的最近公共祖先（离线）

- **题型**：倘若树做为数组展平后，想在线/离线快速判断当前区间最高/最低节点。
- **解法**：离线先序遍历配合单调栈。

## [子矩阵](https://www.lanqiao.cn/courses/51805/learning/?id=4072937&compatibility=false)

**难度：** 中等

**标签：** 单调队列、滑动窗口、二维压缩

------

### 题意与思路

我们有一个 $n\times m$ 的矩阵，定义每个子矩阵的「价值」为其中最大值和最小值的乘积。现在要求所有大小为 $a\times b$ 的子矩阵价值之和，对 $998244353$ 取模。

**直接三重循环**对每个子矩阵扫一遍最值是 $O(nmab)$，显然会超时。

优化套路是「**二维单调队列**」——分两步：

把二维问题拆成 **两次一维滑窗**，彻底去掉对 $a$ 和 $b$ 的线性枚举。

#### 1. 竖向压缩（高度为 a 的滑窗）

- **目标**：对每一列 $j$，求出所有高度为 $a$ 的窗口最小值（同理最大值），生成两个大小为 $(n-a+1)\times m$ 的矩阵 `col_min`、`col_max`。
- **操作**：
  - 遍历列号 $j=0\ldots m-1$。
  - 对当前列构造一个长度为 $n$ 的数组 $[A[0][j],A[1][j],\dots,A[n-1][j]]$。
  - 用单调队列（高度 $a$）做滑窗：
    1. **入队**：每遇到行 $i$，执行一次 `push(i, A[i][j])`。
    2. **淘汰过期**：如果队首的行号 $\le i-a$，就 `popleft()`。
    3. **保持单调**：新值进来前，尾部比它更劣的元素都 `pop()` 掉，保证队首始终是当前窗口最值。
    4. 当 $i\ge a-1$ 时，窗口 $[i-a+1..i]$ 已满，把队首值写入 `col_min[i-a+1][j]`。
- **摊还复杂度**：
  - 每个元素 $(i,j)$ **只入队一次**，只因“被淘汰”才出队一次 → 入出队共 $O(1)$ 摊还。
  - 整列共做 $n$ 次这样的操作；所有列合计 $m$ 列 → **$O(nm)$**

#### 2. 横向滑窗累加（宽度为 b 的滑窗）

- **目标**：在上一步的 `col_min` 与 `col_max` 矩阵（行数 $n-a+1$，列数 $m$）上，对每行再做宽度为 $b$ 的滑窗，得到每个 $a\times b$ 子矩阵的最小/最大值，直接相乘累加。
- **操作**：
  - 遍历行号 $i=0\ldots n-a$。
  - 对当前行的长度-$m$ 数组 `col_min[i]`，用单调队列做宽度 $b$ 的滑窗：同样是 `push(j, col_min[i][j])` + 淘汰过期 + 保持单调；当 $j\ge b-1$ 时，队首给出当前滑窗最小。
  - `col_max[i]` 同理得最大。
  - 对应位置乘积加到答案上。
- **摊还复杂度**：
  - 每个中间矩阵元素 $(i,j)$ 又入队一次、出队一次 → $O(1)$ 摊还；
  - 每行 $m$ 次操作，共 $(n-a+1)$ 行 → **$O((n-a+1)\,m)\approx O(nm)$**

#### 三、为何最终是 O(nm)，而不带 a 或 b

1. **每个元素只进出队列常数次**
   - 无论滑窗多宽（$b$）或多高（$a$），队首只会因“过期”出队一次，队尾只会因“后面更优”出队一次。
   - 每次 `push` 最多伴随一次批量 `pop`，但摊还到整个序列仍是 $O(1)$ 平均。
2. **总操作数 ≈ 队列操作次数**
   - 竖向阶段做了 $\,n\times m$ 次 `push`，对应的出队同样次数级别 → $O(nm)$
   - 横向阶段又做了 $(n-a+1)\times m$ 次 `push` → 也 $O(nm)$
   - 没有额外乘上 $a$ 或 $b$，因为它们只影响“哪个元素先出队”，而不影响出入队次数。

------

### 代码

```python
# ---------- 单调队列模板 ----------
from collections import deque

class Std:
    class MonoDequeIdx:
        def __init__(self, is_min: bool = True, size: int = None) -> None:
            # 存 (idx, val)，idx 用于淘汰过期，val 用于保持单调
            self.dq = deque()
            self.size = size
            # is_min=True 维护递增队列（队首最小），False 维护递减队列（队首最大）
            if is_min:
                self._cmp = lambda x, y: x <= y
            else:
                self._cmp = lambda x, y: x >= y

        def push(self, idx: int, val: int) -> None:
            # 1. 淘汰过期元素
            if self.size is not None:
                expire = idx - self.size
                while self.dq and self.dq[0][0] <= expire:
                    self.dq.popleft()
            # 2. 保持单调
            while self.dq and self._cmp(val, self.dq[-1][1]):
                self.dq.pop()
            # 3. 入队
            self.dq.append((idx, val))

        def query(self) -> int:
            # 队首即当前窗口最值
            return self.dq[0][1]


# ---------- 主流程 ----------
MOD = 998244353

# 读入 n, m, a, b
n, m, a, b = IO.read()

# 读入原矩阵
arr = Arr.array2d(0, n, m)
for i in range(n):
    arr[i] = IO.read_list()

# 1. 竖向滑窗：对每列 j 压缩成 (n-a+1)×m 的 col_min/col_max
col_min = Arr.array2d(0, n - a + 1, m)
col_max = Arr.array2d(0, n - a + 1, m)

for j in range(m):
    dq_min = Std.MonoDequeIdx(is_min=True,  size=a)
    dq_max = Std.MonoDequeIdx(is_min=False, size=a)
    for i in range(n):
        dq_min.push(i, arr[i][j])
        dq_max.push(i, arr[i][j])
        if i >= a - 1:
            col_min[i - a + 1][j] = dq_min.query()
            col_max[i - a + 1][j] = dq_max.query()

# 2. 横向滑窗：在每行 col_min/col_max 上用宽度 b 累加答案
ans = 0
for i in range(n - a + 1):
    dq_min = Std.MonoDequeIdx(is_min=True,  size=b)
    dq_max = Std.MonoDequeIdx(is_min=False, size=b)
    for j in range(m):
        dq_min.push(j, col_min[i][j])
        dq_max.push(j, col_max[i][j])
        if j >= b - 1:
            ans = (ans + dq_min.query() * dq_max.query()) % MOD

print(ans)
```

## [计数质数间隔平衡子数组](https://leetcode.cn/problems/count-prime-gap-balanced-subarrays/description/)

**难度：中等**
**标签：双指针／滑动窗口，单调队列，埃氏筛，数论**

**题意与思路：**

> 给定一个整数数组 `nums` 和一个整数 `k`，统计所有子数组，使得：
>
> 1. 子数组中包含 **至少两个** 质数；
> 2. 最大质数 − 最小质数 ≤ k。

### 整体思路

我们用一次 **滑动窗口** 枚举子数组的右端 `right`，并维护一个可动的左端 `left`，保证窗口内始终满足“最大质数 − 最小质数 ≤ k”。同时，我们还要保证窗口内至少有两个质数，并统计以当前 `right` 结尾的所有合法子数组个数。

具体做法：

1. **质数预处理**

   - 先用埃氏筛（范围至 `max(nums)` 或题目给定上限）算出 `is_prime[x]`。

2. **维护三队列**（都存下标）

   - **`qmax`：** 单调递减，保持队首下标所指 `nums[...]` 是当前窗口内的最大质数。
   - **`qmin`：** 单调递增，保持队首下标所指 `nums[...]` 是当前窗口内的最小质数。
   - **`qPrimeIdx`：** 普通队列，存当前窗口内所有质数的下标（先进先出）。

3. **滑动窗口流程**

   ```python
   left = 0
   ans = 0
   for right, v in enumerate(nums):
       # —— 新元素入窗口 —— 
       if is_prime[v]:
           # 更新 qmax
           while qmax and nums[qmax[-1]] < v:
               qmax.pop()
           qmax.append(right)
           # 更新 qmin
           while qmin and nums[qmin[-1]] > v:
               qmin.pop()
           qmin.append(right)
           # 记录所有质数
           qPrimeIdx.append(right)
   
       # —— 收缩 left，直到 maxPrime - minPrime ≤ k —— 
       #    （qmax/qmin 为空时说明窗口内质数 <2，diff 无意义也不做收缩）
       while qmax and qmin and nums[qmax[0]] - nums[qmin[0]] > k:
           left += 1
           if qmax and qmax[0] < left:
               qmax.popleft()
           if qmin and qmin[0] < left:
               qmin.popleft()
           if qPrimeIdx and qPrimeIdx[0] < left:
               qPrimeIdx.popleft()
   
       # —— 统计以 right 结尾的所有合法子数组 —— 
       # 只需保证“至少 2 个质数”：
       if len(qPrimeIdx) >= 2:
           # 窗口内倒数第 2 个质数的下标 second_last
           second_last = qPrimeIdx[-2]
           # 合法子数组的左端 s 必须满足 left ≤ s ≤ second_last
           # 共 second_last - left + 1 种
           ans += (second_last - left + 1)
   return ans
   ```

- **为什么二者都满足？**

  - 收缩后 `[left…right]` 保证了 `maxPrime - minPrime ≤ k`，任何子区间也同样满足。
  - `s ≤ second_last` 保证包含窗口中前两个质数。

- **为什么要用“倒数第二个”而不是“第二个”？**

  我们要统计所有以 `right` 为右端的子数组 `[s…right]`，只要它包含**任意两个**质数都行。
   窗口里最新出现的两个质数的下标是 `p_{m-1}` 和 `p_m`。

  - 如果你让 `s ≤ p_{m-1}`，那么子数组 `[s…right]` 一定能同时包含这两个质数。
  - 如果你让 `s > p_{m-1}`，那就只能包含最后一个质数 `p_m`，就只有 1 个质数了，不够。

  所以，“倒数第 2 个”质数下标 **正好** 给出了 “保证至少两个质数还能同时留在 `[s..right]`” 的**最右**左端位置。

- **复杂度**

  - 时间：O(n) —— `right`、`left` 各单调移动最多 n 步，每个下标在三队列里最多进/出各一次。
  - 空间：O(n) —— 最坏情况下三个队列共存所有下标。

------

**代码：**

```python
from collections import deque
from typing import List

class Solution:
    def primeSubarray(self, nums: List[int], k: int) -> int:
        n = len(nums)
        if n < 2:
            return 0

        # 1. 质数预处理（假设 nums[i] ≤ 5e4）
        MAXV = max(nums)
        is_prime = [True] * (MAXV + 1)
        is_prime[0] = is_prime[1] = False
        p = 2
        while p * p <= MAXV:
            if is_prime[p]:
                is_prime[p*p : MAXV+1 : p] = [False] * (((MAXV - p*p)//p) + 1)
            p += 1

        # 2. 三个队列，存下标
        qmax = deque()      # 单调递减 ⇒ 窗口最大质数在 nums[qmax[0]]
        qmin = deque()      # 单调递增 ⇒ 窗口最小质数在 nums[qmin[0]]
        qPrimeIdx = deque() # 窗口内所有质数的下标

        left = 0
        ans = 0

        # 3. 滑动右端 right
        for right, v in enumerate(nums):
            # 新质数入队
            if is_prime[v]:
                while qmax and nums[qmax[-1]] < v:
                    qmax.pop()
                qmax.append(right)

                while qmin and nums[qmin[-1]] > v:
                    qmin.pop()
                qmin.append(right)

                qPrimeIdx.append(right)

            # 收缩 left，保持 maxPrime - minPrime ≤ k
            while qmax and qmin and nums[qmax[0]] - nums[qmin[0]] > k:
                left += 1
                if qmax and qmax[0] < left:
                    qmax.popleft()
                if qmin and qmin[0] < left:
                    qmin.popleft()
                if qPrimeIdx and qPrimeIdx[0] < left:
                    qPrimeIdx.popleft()

            # 统计以 right 结尾的所有子数组
            if len(qPrimeIdx) >= 2:
                second_last = qPrimeIdx[-2]
                ans += (second_last - left + 1)

        return ans
```



另外看一个 `O(n log n)` 的做法——**ST + 二分 / 滑动窗口**：

1. **质数预处理**

   - 用埃氏筛预先标记出所有 `≤50020` 范围内的质数。

2. **构造两个数组**

   - `nums_min[i] = nums[i]` 若 `nums[i]` 是质数，否则 `+INF`；
   - `nums_max[i] = nums[i]` 若 `nums[i]` 是质数，否则 `−INF`。

3. **建 Sparse Table**

   - `st_min` 在 `nums_min` 上，查询区间最小值返回**最小质数**。
   - `st_max` 在 `nums_max` 上，查询区间最大值返回**最大质数**。
   - 这样对任意区间 `[l…r]`，`st_max.query(l,r) - st_min.query(l,r)` 就是区间内最大质数与最小质数的差。

4. **前缀质数计数**

   - `pre[i] = nums[0…i-1]` 里质数的个数，用来 `O(1)` 判断某区间是否有 `>=2` 个质数。

5. **所有质数下标**

   - `prime_pos = [i for i,v in enumerate(nums) if is_prime[v]]`，方便快速定位“第 2 个质数”下标。

6. **枚举左端 i + 二分右端**

   ```python
   ans = 0
   p = 0           # 在 prime_pos 上的游标
   for i in range(n):
       # ① 把 p 推到第一个 ≥ i 的质数
       while p < m and prime_pos[p] < i:
           p += 1
       if p+1 >= m:  # 剩余质数不足 2 个
           break
       lb = prime_pos[p+1]   # right 端至少要到第二个质数才可能 valid
   
       # ② 在 [lb…n-1] 上二分，找最大的 r 使区间 [i,r] 合法
       l, r, best = lb, n-1, -1
       while l <= r:
           mid = (l + r + 1) >> 1
           if pre[mid+1] - pre[i] >= 2 \
              and st_max.query(i,mid) - st_min.query(i,mid) <= k:
               best = mid
               l = mid + 1
           else:
               r = mid - 1
   
       # ③ best 即为最远合法右端，所有 [i…j] (j∈[lb…best]) 都是合法的
       if best != -1:
           ans += best - lb + 1
   return ans
   
   ```



```python
# Constants
N = int(2e5 + 10)
M = int(20)
INF = int(6e4)
OFFSET = int(100)
MOD = int(1e9 + 7)

# Set recursion limit
setrecursionlimit(int(1e7))


class Arr:
    array = staticmethod(lambda x=0, size=N: [x() if callable(x) else x for _ in range(size)])
    array2d = staticmethod(lambda x=0, rows=N, cols=M: [Arr.array(x, cols) for _ in range(rows)])
    graph = staticmethod(lambda size=N: [[] for _ in range(size)])

class Math:
    max = staticmethod(lambda a, b: a if a > b else b)
    min = staticmethod(lambda a, b: a if a < b else b)

class Std:
    class SparseTable:
        def __init__(self, data: List, func=lambda x, y: x | y):
            n = len(data)
            self.func = func
            self.st = [list(data)]
            self.lg = Arr.array(0, n + 1)
            for i in range(2, n + 1):
                self.lg[i] = self.lg[i >> 1] + 1
            k = self.lg[n]
            step = 1
            for _ in range(k):
                prev = self.st[-1]
                self.st.append([func(prev[i], prev[i + step]) for i in range(n - (step << 1) + 1)])
                step <<= 1

        def query(self, l: int, r: int) -> int:
            k = self.lg[r - l + 1]
            return self.func(self.st[k][l], self.st[k][r - (1 << k) + 1])

    class EratosthenesSieve:
        def __init__(self, n: int):
            self.n = n
            self.is_prime = [True] * (n + 1)
            self.primes = []
            self._sieve()

        def _sieve(self):
            self.is_prime[0] = self.is_prime[1] = False
            for i in range(2, self.n + 1):
                if self.is_prime[i]:
                    self.primes.append(i)
                    if i * i > self.n:
                        continue
                    for j in range(i * i, self.n + 1, i):
                        self.is_prime[j] = False

class Solution:
    def primeSubarray(self, nums: List[int], k: int) -> int:
        n = len(nums)
        if n < 2:
            return 0
        es = Std.EratosthenesSieve(50020)
        nums_min = [num if es.is_prime[num] else INF for num in nums]
        nums_max = [num if es.is_prime[num] else -INF for num in nums]

        st_min = Std.SparseTable(nums_min, Math.min)
        st_max = Std.SparseTable(nums_max, Math.max)

        pre = [0] * (n + 1)
        for i, v in enumerate(nums, 1):
            pre[i] = pre[i - 1] + (1 if es.is_prime[v] else 0)

        prime_pos = [idx for idx, v in enumerate(nums) if es.is_prime[v]]
        m = len(prime_pos)
        if m < 2:
            return 0

        ans, p, r = 0, 0, -1
        qmax = st_max.query
        qmin = st_min.query

        for i in range(n):
            while p < m and prime_pos[p] < i:
                p += 1
            if p + 1 >= m:
                break
            lb = prime_pos[p + 1]
            
            l, r, best = lb, n - 1, -1
            pll = pre[i]
            while l <= r:
                mid = (l + r + 1) >> 1
                if pre[mid + 1] - pre[i] >= 2 and qmax(i, mid) - qmin(i, mid) <= k:
                    best = mid
                    l = mid + 1
                else:
                    r = mid - 1

            if best != -1:
                ans += best - lb + 1
                
            
        return ans
```



