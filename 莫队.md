# 分块 莫队





```python
from collections import defaultdict
import sys
import math

sys.setrecursionlimit(1 << 25)

def mo_algorithm(arr, query_list):
    n = len(arr)
    q = len(query_list)
    block_size = int(n ** 0.5)

    # 给每个查询加上编号
    queries = [(l, r, i) for i, (l, r) in enumerate(query_list)]

    # 蛇形排序（块内奇偶优化）
    queries.sort(key=lambda x: (
        x[0] // block_size,
        x[1] if (x[0] // block_size) % 2 == 0 else -x[1]
    ))

    # 答案数组
    res = [0] * q

    # 当前指针和答案
    l, r = 0, -1
    freq = defaultdict(int)
    current_ans = 0

    def add(x):
        nonlocal current_ans
        freq[arr[x]] += 1
        if freq[arr[x]] == 1:
            current_ans += 1

    def remove(x):
        nonlocal current_ans
        freq[arr[x]] -= 1
        if freq[arr[x]] == 0:
            current_ans -= 1

    for L, R, idx in queries:
        while r < R:
            r += 1
            add(r)
        while r > R:
            remove(r)
            r -= 1
        while l < L:
            remove(l)
            l += 1
        while l > L:
            l -= 1
            add(l)

        res[idx] = current_ans

    return res
```





## 介绍

### 一、什么是分块？

#### 基本思想：

**把数组平均分成 √n 个小块，然后每个块上预处理一些信息，来加速查询。**

举个最简单的例子：
 你有一个数组 `arr = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]`，要回答多个“区间和”的查询。

正常你要每次暴力累加，复杂度是 `O(N)`。

那怎么优化？

------

#### 分块做法：

假设数组长度是 10，开根号是 3，分成 3~4 个块：

```
块 0：索引 [0, 2]
块 1：索引 [3, 5]
块 2：索引 [6, 8]
块 3：索引 [9]
```

我们可以提前求出每个块的总和：

```python
block_sum = [9, 18, 18, 10]
```

那你查询区间 `[2, 7]` 的和，就可以这样搞：

- `2` 到 `2`：自己暴力加（块头尾不齐）
- `3` 到 `5`：整块，直接加 `block_sum[1]`
- `6` 到 `7`：暴力加（尾巴）

总共只处理了两段“残缺”，中间整块直接拿结果。

最多就是中间t个整段，然后两边两个段，段的长度为m的话，复杂度为$n/m + 2m$，当且仅当$m = \sqrt{n}$

这样时间复杂度是：

> 查询一个区间是 `O(√N)`，比原来的 `O(N)` 快得多！

------

#### 分块适合处理：

- 区间和
- 区间最大/最小值
- 区间统计（频率/种类）等等

而且还能支持修改（比如单点改值），灵活性比树状数组还强一点。

------

### 二、那莫队是怎么来的？

#### 莫队 = 分块 + 多个查询 + 不修改（离线）

你如果一次只查一个区间，分块就够了，但：

> 假如现在有 **上万个区间查询** `(L, R)`，而且数组是**静态不变的**，那怎么搞？

暴力扫一遍还是不够快，即使用了分块，还是有很多重复计算（因为查询之间没共用任何结果）。

所以：**莫队的想法就是：把所有查询“排好序”，用两个指针滑动着跑，把之前的结果复用上。**

------

### 三、莫队算法：从“分块”到“极限滑动”

#### 如何排序查询？

我们依然把数组分成 `√n` 个块。

对于所有的查询 `(L, R)`，我们按如下方式排序：

- **先看左端点 `L` 在哪个块里**（也就是 `L // block_size`）；
- 如果在同一个块里，那就让右端点 `R`：
  - 如果当前块编号是偶数，就升序排；
  - 是奇数，就降序排；
  - 这样能让 `R` 的移动变得少。

这个排序方式，就是所谓的“莫队排序”，它能最大程度地复用上一个查询的结果（防止只按L和R排序，然后另一个来回跳）。

------

#### 接着怎么做？

用两个指针 `cur_l`, `cur_r` 来维护当前的区间 `[cur_l, cur_r]`。

对于每个排序后的查询 `(l, r)`：

- 如果 `cur_r < r`，说明右端没到，多加几个数；
- 如果 `cur_r > r`，说明右端多了，删几个；
- 同理处理 `cur_l`。

每加一个数、删一个数，就调用我们写好的 `add()` 和 `remove()` 函数更新答案。

最终每次查询就能在 “指针移动的次数” 上耗时，单次操作是 O(1)。

------

### 四、为什么莫队复杂度是 √N？

你一共有 `Q` 个查询。

- 每个查询的指针移动总共不超过 `2√N` 次（左右指针都不会“跳太远”）；
- 所以总共的“移动成本”是 `O(Q * √N)`；
- 每次移动调用 `add()`、`remove()` 都是 `O(1)` 的。

整体复杂度是：

> `O((N + Q) * √N)`，比暴力的 `O(NQ)` 快很多！

------

### 五、总结一下

| 算法 | 特点                     | 复杂度            | 适用场景                     |
| ---- | ------------------------ | ----------------- | ---------------------------- |
| 分块 | 一般处理单个区间查询     | `O(√N)`           | 区间和、区间最大、最小       |
| 莫队 | 处理**多个静态区间查询** | `O((N + Q) * √N)` | 区间种类数、区间众数、区间和 |

------

