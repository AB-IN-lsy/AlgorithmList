# 自用结论

## 比赛小技巧

### 一、题型与思路识别

1. **填空题**  
   - 可能较难，暴力不一定能过，先试简单思路，再往算法方向考虑。

2. **思维题**  
   - 编程题的前两道往往是简单的思维／实现题，先不要急着过度优化。

3. **方案数/计数**  
   - 如果要求方案数，考虑数学组合、线性 DP、状态压缩等计数技巧。

4. **树相关**  
   - 看到 “n 个点、n−1 条边”，第一时间往树上想：DFS／BFS、LCA、树形 DP、差分约束 等。

5. **字符串**  
   - 求最长公共前缀/后缀、出现次数、不同子串数量，优先考虑 Hash 算法（rolling hash）、KMP、后缀数组等。

6. **区间/查询**  
   - 看到区间修改或查询，考虑前缀和、差分、分块、线段树、树状数组。

7. **最优值（最大/最小）**  
   - 考虑二分法、贪心（先排序）、动态规划（DP）。

8. **状态范围小**  
   - 如果某个状态维度特别小，考虑状态压缩（二进制掩码 DP）、位运算技巧或配合其他算法。

9. **图的最优路径/生成树**  
   - 看到求最短/最长路径，或“最大化最小边”之类，考虑 Dijkstra、Bellman-Ford、Floyd，或最小生成树（Kruskal/Prim）。

10. **集合关系**  
    - 求连通/合并/查询等，考虑并查集（DSU）、带权并查集。

11. **无明显特征**  
    - 如果实在没头绪，先想一想贪心能不能用，或者能否转换成别的经典模型。

12. **可行性判断（二分答案）**  
    - 枚举答案，看是否满足 “01 函数”（可以判断解是否成立），典型二分思路。

### 二、复杂度估算

> 一般允许的运算量 ≈ \(10^7\) ～ \(10^9\)

- **\(n \le 10^5\)**  
  - \(O(n\log n)\), \(O(n\sqrt n)\), \(O(n\log^2 n)\)
- **\(n \approx 10^6\)**  
  - \(O(n\log n)\)
- **\(n \le 5000\)**  
  - \(O(n^2)\)
- **\(n \le 500\)**  
  - \(O(n^3)\)

## 1. 字符串不含长度 ≥ 2 的回文串的条件

- **结论：** 如果一个字符串中任意字符都不与它前两个字符相同，那么这个字符串就**不含任何长度 ≥ 2 的回文子串**。
- **原理：** 长度为2的回文要求 `s[i] == s[i+1]`，长度为3的回文要求 `s[i] == s[i+2]`。防止和前两位重复就能规避所有情况。
- **习惯做法：** 推结论时可从长度为 1、2 开始向上归纳。

------

## 2. 奇偶统计技巧：异或处理

- **结论：** 遇到“奇偶校验”问题，可以用 **异或操作 (`^`)** 将奇偶状态编码为 0 和 1。
- **技巧：** 若某个数 x 当前是奇数，用 `x ^ 1` 得到偶数；反之亦然。
- **应用：** 统计前缀中奇偶个数、位运算、状态压缩等。

------

## 3. 状态压缩的典型场景

- **结论：** 当问题中涉及 **“元素数量 < 20 且组合枚举”**，可以考虑用 **状态压缩**。
- **常见场景：** 子集枚举、状压 DP、状态转移图。
- **技巧：** 用一个 `int`（或 `bitset`）来记录若干布尔状态。

------

## 4. 前缀和 + 哈希表求和为 k 的最长子串

- **结论：** 使用前缀和 + 哈希表记录首次出现某个前缀和的位置，可以在 O(n) 内求得 **最长连续子串使和为 k**。

- **代码片段：**

  ```python
  pre = 0
  seen = {0: -1}
  for i, x in enumerate(nums):
      pre += x
      if pre - k in seen:
          max_len = max(max_len, i - seen[pre - k])
      seen.setdefault(pre, i)
  ```

------

## 5. 奇偶交替序列的长度统计

- **结论：** 表达式

  ```python
  1 + sum((x & 1) ^ (y & 1) for x, y in pairwise(nums))
  ```

  即为 **奇偶交替子序列的长度**。

- **解释：** `(x & 1)` 得到奇偶性，异或判断相邻是否交替。

------

## 6. DFS 中 for 枚举 vs 回溯顺序

- **结论：** 如果 DFS 中通过 `for` 加入未选元素，会**考虑排列顺序**；若需组合，应控制递归起点防止重复。
- **常见错误：** 忘记 `start`，导致 `[1,2]` 与 `[2,1]` 重复计数。
- **补充建议：** 排列问题不需要 `start` 参数，组合问题要避免重复。

------

## 7. 中位数与绝对值和最小：货仓选址问题

- **结论：** 给定有序数组 X，最小化
   $\sum_{i=1}^{n} |x_i - p|$
   的 p 是 X 的 **中位数**。
- **原理：** 绝对值函数的最小化在中点达成，数学归纳/图像直观均可证明。
- **应用：** 快速求绝对值代价最小的聚集点。

------

## 8. 常见运算的单调性总结

- 可以利用单调性进行 **二分优化** 或 **ST表预处理**。以下为常见操作的趋势：

| 操作类型            | 单调性描述   |
| ------------------- | ------------ |
| `a & b`（按位与）   | 非递增       |
| `gcd(a, b)`         | 非递增       |
| `a | b`（按位或） |   非递减 
| `lcm(a, b)`         | 非递减       |
| 数组求和 `sum(a)`   | 单调递增     |
| 数组最大值 `max(a)` | 单调递增     |
| 数组最小值 `min(a)` | 单调递减     |

- **技巧补充：**
  - 若操作具有单调性，可以**固定一端，二分另一端**。
  - 双变量问题中，常见套路是 **枚举一个变量**，把另一个用前缀结构维护。



非常好，这些总结依然非常实用，而且覆盖了不少易错点和典型建模套路。我已将你新发的内容整理成结构统一、逻辑清晰的 Markdown 笔记风格，并补充了一些适用场景、推理说明或建议。

------

## 9. 位运算与集合思想建模

- **结论：** 许多涉及子集、集合并交、开关状态、选择方案等问题可以用 **二进制的每一位表示一个元素是否出现**。
- **典型应用：**
  - 状压 DP（如旅行商问题、子集覆盖）
  - 快速判重、集合合并（如两个集合按位与是否为 0）
- **图示参考：**🔗 [参考链接](https://leetcode.cn/circle/discuss/CaOJ45/)

------

## 10. 曼哈顿距离坐标变换公式

- **结论：** 对点 $(x, y)$ 进行如下变换：

  - $A = x + y$
  - $B = x - y$
     则曼哈顿距离可转为切比雪夫距离：

  $dM=∣x1−x2∣+∣y1−y2∣=max⁡(∣A1−A2∣,∣B1−B2∣)d_M = |x_1 - x_2| + |y_1 - y_2| = \max(|A_1 - A_2|, |B_1 - B_2|)$

- **用途：**

  - 曼哈顿距离最远点转换为 `max` 问题，适合快速求解

- 🔗 [几何距离转换参考](https://oi-wiki.org/geometry/distance/)

------

## 11. LCS 与 LIS 的转化技巧

- **结论：** 如果其中一个数组的元素互不相同，则**最长公共子序列（LCS）问题可以转化为 LIS 问题**。
- **做法：**
  - 用一个哈希表将一个数组中的元素映射为下标
  - 将另一个数组中的公共元素映射为下标序列
  - 在这个下标序列上求 LIS 即为原 LCS
- **LIS 解法补充：**
  - 贪心 + 二分：`O(n log n)`
  - 树状数组 / 线段树优化：可处理区间更新型变种

### 举个例子说明：

```
A = [3, 4, 9, 1]
B = [5, 3, 8, 9, 10]
```

1. **目标：** 找出 `A` 和 `B` 的最长公共子序列（LCS）

2. **转换：**

   - 把 B 中元素的位置映射出来：

     ```
     pos = {val: idx for idx, val in enumerate(B)}  # {5:0, 3:1, 8:2, 9:3, 10:4}
     ```
     
   - 遍历 A，提取那些出现在 B 中的元素，映射为它们在 B 中的下标：
   
     ```
      A_mapped = [pos[x] for x in A if x in pos]  # 得到 [1, 3]
     ```

3. **在 `[1, 3]` 上求 LIS，就是原 LCS 的长度**（因为在 B 中位置递增就说明顺序一致）

------

## 12. 子数组中所有数按位与为 0 的条件

- **结论：** 若一个子数组中所有数按位与为 0，等价于它们对应的“集合”之间无重叠（交集为空）。
- **等价模型：**
  - 可将每个数视作一个“包含若干位为 1 的集合”
  - 任意两个集合之间的交必须为空：`x & y == 0`
- 🔗 [原文参考](https://leetcode.cn/circle/discuss/CaOJ45/)

------

## 13. 模运算的恒等式总结（需牢记！）

```python
(a + b) % mod = (a % mod + b % mod) % mod
(a - b) % mod = (a % mod - b % mod + mod) % mod
(a * b) % mod = ((a % mod) * (b % mod)) % mod
(a / b) % mod = (a * b^(mod - 2)) % mod   # mod 为质数时
```

- **注意：**
  - 除法要用乘上逆元的方式，通常用 `b^(mod - 2)` 求逆元（Fermat 小定理，mod 为质数）
  - 减法后记得加 `mod` 保证非负

------

## 14. reduce / max / min 前需判空！

- **结论：** Python 中使用 `max() / min() / reduce()` 等聚合函数时，**必须确保传入序列非空**，否则会抛出异常。

- **建议做法：**

  ```python
  if seq:  # 非空才使用 max/min
      max_val = max(seq)
  else:
      max_val = default_val
  ```





继续整理你的总结如下，我已统一格式、优化语言，并对关键概念做了扩展解释，让内容更适合归档复习：

------

## 15. 记忆化搜索技巧与注意事项

- **结论 1：** Python 中进行记忆化搜索可直接使用 `@lru_cache` 装饰器，非常方便。

  ```python
  from functools import lru_cache
  
  @lru_cache(maxsize=None)
  def dfs(x, y):
      ...
  ```

- **注意：** 用完后别忘了在主函数尾部调用：

  ```python
  dfs.cache_clear()
  ```

  以免下次调用缓存复用或导致 **爆内存**（特别是多次调用 `main()` 或刷题时）

- **结论 2：** 既然已经用了 `@lru_cache`，**就不要再额外使用 vis 数组**（如 `visited[][]`）来判重，重复记录会浪费空间且容易出错。

------

## 16. “两个区间/两个点”类型题目常见套路

- **常见题型描述：**
  - 给你一个点/线段，让你找另一个满足某种限制的点/线段组合最优解
- **常用套路：**
  1. **前后缀分解**：预处理某些方向上的最值、DP 状态
  2. **枚举右端点，维护左端状态**：结合滑窗、单调队列、前缀和、二分等技巧
     - 类似双指针/窗口滑动模式
     - 保证左边状态单调/递增/可快速转移
- **例题：**
  - LeetCode 1498（满足和小于 target 的子序列数目）
  - 牛客双指针、最长区间等题

> 一句话总结：两个点/线段题一般考虑枚举一边，另一边用“滑窗 + 预处理”来做。

------

## 17. KMP 与 Z-函数基础

### KMP 中的 next 数组定义：

- `next[i]` 表示 `P[0:i]` 这个前缀中，最长的“**相等前后缀**”的长度（不包括自身）

- 示例：

  模式串：`P = a a b a a b a a a a`
   得到：

  ```
  i:    1 2 3 4 5 6 7 8 9 10
  ne[]: 0 1 0 1 2 3 4 5 2 3
  ```

- 含义：
   比如 `ne[6] = 3`，说明 `P[0:3] == P[3:6]`，即前后缀 `"aab"` 相等。

------

### Z-函数定义：

- 对于字符串 `S`，`z[i]` 表示 `S` 与 `S[i:]` 的最长公共前缀（LCP）长度。
- 示例：
   `S = a a a b a a a b c`
   `z = - 2 1 0 4 2 1 0 0`（`z[0]` 一般忽略）
- **用途：**
  - 字符串快速匹配
  - 求重复前缀
  - 有些题 Z 比 KMP 更简单

------

## 18. 二分法实用技巧：上界怎么设？

- **结论：** 若无法直接算出二分的上界（如最大值/最大答案），推荐默认上界为：

  ```python
  hi = int(1e12)  # 对整数答案足够安全
  ```

- **为什么用这么大：**

  - 常见题目中数据范围在 `1e5` ~ `1e9` 左右
  - 且通常 log(n) 层级处理 `1e12` 足够快（不会超时）



明白了，你想要一个**结构清晰、总结性强的模板型笔记**，一目了然地知道：

- 什么题型用什么套路；
- 每个套路怎么写；
- 对应题中代码的意义。

我把你这道题抽象为模板，再结合泛用思路，整理如下👇

------

## 19. 区间频率类问题的技巧总结（基于本题）

这类题目特点：

> 多组查询，询问某个区间 `[l, r]` 中是否存在满足 **“频率统计条件”** 的子串（或子串数量）。

------

### 一、前缀频率状态映射

#### 适用题型：

- 判断某个区间是否满足频率条件（如频率相等 / 出现偶数次 / 平衡等）
- 判断某个子串是否是「频率零差」（如异位词、频率模k抵消）

#### 思路：

对每个位置 `i`，构造一个前缀状态 `pre[i]`，表示 `s[0..i-1]` 的字母出现次数（或模k余数、奇偶性等）。

#### 如何判断 `[l, r]` 合法？

看两个前缀状态是否一样：

```text
pre[r+1] == pre[l]  ⇒  s[l..r] 频率差为 0
```

#### 实现方式（本题）：

```cpp
cnt[c] = (cnt[c] + 1) % k;
pre[i+1] = hash(cnt[26]);  // 统计频率模k的状态
```

------

### 二、频率数组哈希化

#### 适用题型：

- 有多个状态数组要比对（如出现次数、奇偶状态、频率分布等）
- 状态数组不好直接比较或不好当作 map 键

#### 思路：

把 `cnt[26]` 这样的数组，用一个函数映射成 `ull` 或者 `int`，作为状态唯一代表。

#### 本题中哈希实现：多项式哈希（推荐通用方法）

##### 思想：

给每个位置（每个字母）一个唯一权重 `base^i`，再累加整个数组：

```python
def init_pow_base():
    pow_base = [1] * 26
    for i in range(1, 26):
        pow_base[i] = (pow_base[i - 1] * BASE) % MOD
    return pow_base

pow_base = init_pow_base()
```



#### 替代方法（Python 特有）：

##### 用元组代替哈希（当数组元素小 / 频率稳定）：

```python
cnt = [1, 2, 0, ..., 1] # 一个字符串中字母的数量
key = tuple(cnt)  # 可直接用于 dict / Counter
```



```python
def get_state_array(s: str, k: int) -> list[tuple[int]]:
    n = len(s)
    cnt = [0] * 26
    states = [tuple(cnt)]  # pre[0] = 空串状态
    for i in range(n):
        c = ord(s[i]) - ord('a')
        cnt[c] = (cnt[c] + 1) % k
        states.append(tuple(cnt))  # pre[i+1]
    return states
```



适合：

- 状态种类有限
- 字母集小（26）
- 不需要高性能哈希（Python 内部已优化）

------

### 三、等值前缀对的计数技巧

#### 适用题型：

- 统计有多少个子串频率状态相同（或差值为 0）
- 找满足某种状态匹配的 `(i, j)` 对数（如异位词、异或值等）

#### 思路：

构造出前缀状态数组 `pre[0..n]` 后，问题就转为：

> **区间 `[l-1, r]` 中有多少对下标 `(i-1, j)` 满足 `pre[i-1] == pre[j]`**

#### 实现方式（经典模板）：

```cpp
sum += cnt[pre[x]];
cnt[pre[x]]++;
```

- 当前哈希值之前出现了几次 → 就是几种配对可能
- 最后总和就是答案

------

### 四、多个区间查询 → 莫队优化

#### 适用题型：

- 数组不修改
- 多次区间 `[l, r]` 查询
- 每次“加点 / 删点”可以 O(1) 维护

#### 思路：

> 把所有查询排序成“块内蛇形”，用滑动窗口高效维护答案。

#### 排序规则（蛇形）：

```python
block_size = int(n ** 0.5)
queries = [(l, r, i) for i, (l, r) in enumerate(query_list)]
queries.sort(key=lambda q: (
    q[0] // block_size,
    q[1] if (q[0] // block_size) % 2 == 0 else -q[1]
))

```

记口诀： “按块编号排，偶升奇降 r。”

#### 操作模板（调整滑窗）：

```python
while r < R:
    r += 1
    add(r)

while r > R:
    remove(r)
    r -= 1

while l < L:
    remove(l - 1)
    l += 1

while l > L:
    l -= 1
    add(l - 1)
```





## 20. 怎么记欧拉函数？欧拉降幂？



另外的欧拉降幂：

![image-20250527210622142](D:\Code\OtherProject\AlgorithmList\images\image-20250527210622142.png)

| 名称             | 公式                                                 | 条件                  | 常见应用                  |
| ---------------- | ---------------------------------------------------- | --------------------- | ------------------------- |
| 费马小定理       | $a^{p} \equiv a \mod p$                              | p 是质数              | 快速幂取模、简化同余式    |
| 欧拉定理         | $a^{\varphi(n)} \equiv 1 \mod n$                     | $\gcd(a, n) = 1$      | 大指数取模降幂            |
| 欧拉降幂（扩展） | $a^b \equiv a^{b \% \varphi(n) + \varphi(n)} \mod n$ | $\gcd(a, n) \ne 1$ 时 | 避免爆幂 + 不互质降幂修正 |

### 欧拉定理 (必须互质)
如果 $\gcd(a, n) = 1$，则：
$$
a^{\varphi(n)} \equiv 1 \pmod{n} \Rightarrow a^b \equiv a^{b \bmod \varphi(n)} \pmod{n}
$$

**安全降幂**

### 欧拉降幂 (不互质 + 指数很大)
如果$\gcd(a, n) \neq 1$，且 $b > \varphi(n)$，不能直接用欧拉定理。
此时保守用：
$$
a^b \equiv a^{b \bmod \varphi(n) + \varphi(n)} \pmod{n}
$$

**不一定能降幂成功，但一定不出错 (安全兜底)**



### 重点！！拓展欧拉定理



$$a^b \equiv 
\begin{cases}
a^{b \bmod \varphi(m)} & \text{if } \gcd(a, m) = 1 \\
a^b & \text{if } \gcd(a, m) \neq 1, b \leq \varphi(m) \\
a^{(b \bmod \varphi(m)) + \varphi(m)} & \text{if } \gcd(a, m) \neq 1, b > \varphi(m)
\end{cases}$$



### 口诀记法（实用、好记）

> **“每个质因子处理一次，换成减一乘回来。”**

也就是：

$\varphi(n) = n \cdot \left(1 - \frac{1}{p_1}\right) \cdot \left(1 - \frac{1}{p_2}\right) \cdots$



$\varphi(n) = n \times \frac{p_1 - 1}{p_1} \times \frac{p_2 - 1}{p_2} \cdots$

------

### 例子为重点！！图里例子：36

- 36 = 2 × 2 × 3 × 3 
- 因为2和3是质因子，类似set过滤一下，只处理一次2和3即可
- 那么：$\varphi(36) = (2 - 1) \cdot 2^{1} \cdot (3 - 1) \cdot 3^{1} = 1 \cdot 2 \cdot 2 \cdot 3 = 12$

------

### 编程实现记法（转化成代码思维）：

> **每次遇到一个质因子 p：**
>
> - 先 `res *= (p - 1)`
> - 再 `res *= p` 直到除尽

这就是你图里的：

```
(2 - 1) * 2^(2 - 1) * (3 - 1) * 3^(2 - 1)
```



或者背成口令版：

> **“一个质因子就换成减一乘 p 的 k-1 次方。”**



埃氏筛批量求欧拉函数（埃氏筛不能用优化版本！！）

* 因为优化版本原理是：i×2,i×3,...,i×(i−1) **这些合数早就被更小的质因子筛掉了**，所以从i*i开始。但在这里会漏掉很多情况



```python
class EulerPhiEratosthenes:
    def __init__(self, n: int):
        self.n = n
        self.phi = [i for i in range(n + 1)]
        self.is_prime = Arr.array(True, n + 1)
        self.primes = []
        self._sieve_phi()

    def _sieve_phi(self):
        self.is_prime[0] = self.is_prime[1] = False
        self.phi[0] = 0
        self.phi[1] = 1

        for i in range(2, self.n + 1):
            if self.is_prime[i]:
                self.primes.append(i)
                self.phi[i] = i - 1
            for j in range(i * 2, self.n + 1, i):  # From i + i to n
                self.is_prime[j] = False
                self.phi[j] = self.phi[j] // i * (i - 1)
```



## 21. 组合问题域多项式乘法？多项式基础

### 简单多项式

在算法竞赛中，我们常遇到这么一类问题：$(a_0 + a_1x + a_2x^2 \ldots a_nx^n) \times (b_0 + b_1x + b_2 + \ldots + b_mx^m)$为多少？
或者在某些组合问题中，常常转换为多项式乘法问题。

### 多项式基础
多项式是代数中的基本概念，在算法竞赛中有着广泛应用。简单来说，一个多项式可以表示为：
$$P(x) = a_0 + a_1x + a_2x^2 + \ldots + a_nx^n$$
其中，$a_i$是系数，$n$是多项式的次数。

### 多项式乘法
给定两个多项式：
- $A(x) = a_0 + a_1x + a_2x^2 + \ldots + a_nx^n$
- $B(x) = b_0 + b_1x + b_2x^2 + \ldots + b_mx^m$

它们的乘积$C(x) = A(x) \times B(x)$是一个次数为$n + m$的多项式

$$C(x) = c_0 + c_1x + c_2x^2 + \ldots + c_{n + m}x^{n + m}$$

其中系数$c_k$的计算公式为：$$c_k = \sum_{i + j = k} a_i \times b_j$$







这张图是**组合数学中生成函数的核心思想**，尤其用于解决**硬币组合问题**等“构造型计数”问题的高级技巧。

------

### “如何把组合问题转化为多项式乘法问题”

------

#### 一、📌 什么是生成函数？

> 把一个序列 $a_0, a_1, a_2, \dots$ 表示成一个多项式：

$G(x) = a_0 + a_1x + a_2x^2 + a_3x^3 + \dots$

这就叫做它的**普通生成函数（Ordinary Generating Function, OGF）**。

每个 $a_n$ 就是我们关心的问题中 “方案数”、“计数值”。

------

#### 二、图中的例子讲了什么？

##### **例题：无限硬币组合问题**

> 有无限多个 1、2、5 面值的硬币，问组成总金额恰好为 `n` 的方案数。

------

##### 思路：每种硬币构造一个生成函数



> **“指数”表示总金额，系数表示该金额的组合方案数**！！！！

| 面值 | 多项式                                       | 含义                             |
| ---- | -------------------------------------------- | -------------------------------- |
| 1元  | $P_1(x) = 1 + x + x^2 + x^3 + \dots$         | 每个 $x^k$ 表示用了 `k` 个1元    |
| 2元  | $P_2(x) = 1 + x^2 + x^4 + x^6 + \dots$       | 每个 $x^{2k}$ 表示用了 `k` 个2元 |
| 5元  | $P_5(x) = 1 + x^5 + x^{10} + x^{15} + \dots$ | 同理                             |

------

##### 核心构造：

把这三个生成函数乘在一起：

$P(x) = P_1(x) \cdot P_2(x) \cdot P_5(x)$

你得到的 $P(x)$ 的展开式中：

- $x^n$ 的系数就表示 **组成金额为 `n` 的所有组合方案数**

> 组合问题中，**“选或不选某种物品”的组合方式** → 转换为 **某个生成函数的乘法展开**，最后只需要取出 $x^n$ 项的系数就能得到答案。

```python
def coin_change_dp(coins, target):
    dp = [1] + [0] * target   # dp[0] = 1，其它为0
    for c in coins:
        for i in range(c, target + 1):
            dp[i] += dp[i - c]
    return dp[target]

```



------

##### 三、应用广泛的生成函数模型：

| 模型                | 生成函数                            |
| ------------------- | ----------------------------------- |
| 每个物品无限次取    | $\frac{1}{1 - x^k}$                 |
| 每个物品只能取一次  | $1 + x^k$                           |
| 多重背包（有限次）  | $1 + x^k + x^{2k} + \dots + x^{mk}$ |
| 全部装满 / 排列方案 | $(1 + x)^n$, $x^n$ 系数             |





## 22. 记忆化搜索注意事项

| 问题类别            | 错误写法 / 情况      | 后果                                                         |
| ------------------- | -------------------- | ------------------------------------------------------------ |
| 参数可变            | 参数是 list/set/dict | ❌ 报错：unhashable type                                      |
| 参数太大            | 参数值如 `o = 2^60`  | ❌ cache key 超大，占内存、查找慢                             |
| 状态不收敛          | 没终止条件 or o*=2   | ❌ 死递归 / 无限展开，爆栈段错误。<br />状态剪枝（极关键） 必须尽早终止无效分支 |
| 无缓存命中          | 状态唯一性太强       | ❌ cache 白开了，退化成暴力                                   |
| Python 默认递归深度 | 超过 1000 层         | ❌打印 `cache_info()`，命中少说明状态设计有问题               |



------

### **经验 1：o \*= 2 是搜索杀手，要立刻“指数化”**

#### 场景

像“李白打酒”这类题，`o` 是一个会不断乘 2 的变量。

#### 错误写法：

```python
dfs(i - 1, j, o * 2)
```

- 每乘一次，状态空间指数上升；
- 最终 `o = 2^60`，就会卡爆栈、爆缓存；
- 就算你加了剪枝，也挡不住它提前爆。

#### 正确姿势：

- 把 `o` 看作 `2^k`，记录 `k`，每次喝花不再操作 `k`，而操作实际值；
- 或者干脆把 `o` 离散化（比如 cap 为 1000，超过就 return 0）；
- 或直接用 DP 重构状态转移。

------

### **经验 2：状态值不一定非得“真实”，只需要“能区分不同路径”就够**

#### 比如：

你不需要真的记录“酒量是 128”，你只要能区分“这个路径比另一个酒多”就够了。

> 所以 **“状态等级” 替代 “状态值”** 是最经典的降维方法。

------

### **经验 3：加一行 `if depth > 30: return 0`，99% 死循环你都能救回来**

#### 为什么有效：

- 某些题你不确定“递归到底能不能结束”；
- 加一个 `depth` 参数，每次递归 `+1`，到了就 return；
- 快速测出是不是“递归方向错了”or“剪枝不够”。

------

### **经验 4：爆栈不是 `dfs()` 出错，是你的状态在“回不来”**

#### 常见原因：

- `dfs(i-1, j, o*2)` 路径走太远，根本不可能返回；
- base case 没写对，导致全路径无终止；
- 某状态永远不会“满足终止条件”但你没拦住它。

------

### **经验 5：调参调不过，就“打印最后10层状态”**

```python
def dfs(...):
    if depth >= LIMIT:
        print("DEEP PATH:")
        print(path[-10:])  # 自己维护一个 path.append(...)
        return 0
```

✅ 你会看到路径在哪个状态“卡死了”，最实用的 debug 手段之一。

------

### **经验 6：一定要记住递归路径不一定“单调”**

#### 举例：

你以为 `o` 会越来越小，但实际上你可能还有遇店，导致它突然变大。

✅ 所以很多剪枝不能写死成 `if o > j: return 0`，除非你能保证**未来状态不会再增大**。

------

### **经验 7：爆了？先打印 `dfs.cache_info()` 看 hits/misses**

```python
print(dfs.cache_info())
# 输出：CacheInfo(hits=3542, misses=1_029_382, currsize=1_000_000)
```

#### 如果命中率低：

- 说明你状态定义得太具体，没有复用；
- 比如你传了 6 个变量，其中 2 个根本不影响路径，那这就是状态爆炸的根源。

------

### **经验 8：调试路径最好别用 print，而是维护一个 `trace` 栈**

```python
trace = []
def dfs(i, j, o):
    trace.append((i, j, o))
    # ...
    trace.pop()
```

这样你在 return 前打印 `trace[-10:]`，能一眼看到当前路径。

------

### **经验 9：@lru_cache 不香？自己写 memo，能加更多信息**

```python
memo = {}
def dfs(i, j, o):
    key = (i, j, min(o, 100))  # cap o
    if key in memo: return memo[key]
    ...
    memo[key] = ans
    return ans
```

✅ 自定义可以加：

- `cap`
- debug info
- 非常规 key
- 删除 key 等操作

------

### **经验 10：状态设计优先级（一定背熟）**

> 状态变量怎么选？你先从这几个角度想：

| 优先级         | 状态类型                                           | 举例 |
| -------------- | -------------------------------------------------- | ---- |
| 🎯 必要的计数器 | `i, j` 表示走了多少步                              |      |
| 🎯 路径相关量   | 比如“当前酒量 o”，“当前位置 pos”，“上一步类型 pre” |      |
| 🎯 附带条件     | 是否喝光、是否走过、是否连续等用 bool 表示         |      |
| 🎯 模运算类状态 | `% k`、`sum % MOD`，记忆常见于背包类               |      |
| ⚠️ 低优先       | “真实数值”比如 o=2^60，容易爆炸，优先压缩          |      |

## 23. 串的最短周期长度 = 串长 – 最长真前后缀长度

这个结论就是 **“串的最短周期长度 = 串长 – 最长真前后缀长度”**：

> **定理**（字符串周期性）
>  设字符串 $S$ 长度为 $n$，其 KMP 前缀函数 $\pi$ 在末尾的位置给出了最长真前后缀长度 $k = \pi[n-1]$。
>  则 $S$ 的最短周期（能够无限自我拼接且包含 $S$ 的最小周期）为
>
> L=n−k

换句话说，只要你算出常说的“$\pi[n-1]$”，答案立刻就出来了：最短周期就是 **$n - \pi[n-1]$**。







## 24. 最少插入字符数成为回文串 -> 最长回文前缀长度

“对任意字符串 S，令 T = S + '#' + reverse(S)，计算 T 的前缀函数 π，
 则 π[|T|−1] 恰好是 S 的最长回文前缀长度；
 因此，最少需要在 S 前插入的字符数 = |S| − π[|T|−1]，
 而插入的具体字符就是 reverse(S[π[|T|−1]…])。”





## 25. 最少删除变回文 —— 结论

> 对长度为 $n$ 的字符串 $S$，要把它 **变成回文**，**最少** 要删除的字符数
> $$
> \boxed{\;n - \mathrm{LPS}\;}
> $$
> 其中 $\mathrm{LPS}$（Longest Palindromic Subsequence）是 $S$ 的**最长回文子序列**长度。



### 为什么 LPS = LCS$(S,\; \mathrm{reverse}(S))$

- 设 $T = \mathrm{reverse}(S)$。
- 任取一个回文子序列 $P$（长度为 $k$）：
  - 在原串 $S$ 中，$P$ 按顺序出现；
  - 它反过来也和自己相同，所以在 $T$ 中也按顺序出现。
- 于是 $P$ 同时是 $S$ 和 $T$ 的一个**公共子序列**。
- 反过来，任何 $S$ 和 $T$ 的公共子序列，读起来在 $S$ 里是正向，在 $T$ 里是反向，必然是回文。
- 故最长回文子序列长度 = 最长公共子序列长度（LCS）$\bigl(S,T\bigr)$。



------

### 代码模板

```python
def min_deletions_to_palindrome(s: str) -> int:
    n = len(s)
    t = s[::-1]
    # dp[i][j] = LCS 长度，s[:i] vs t[:j]
    dp = [[0]*(n+1) for _ in range(n+1)]
    for i in range(n):
        for j in range(n):
            if s[i] == t[j]:
                dp[i+1][j+1] = dp[i][j] + 1
            else:
                dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])
    lps = dp[n][n]
    return n - lps

# 示例
print(min_deletions_to_palindrome("agbcba"))  # 输出 1
```

- **第一步** 用经典的 LCS 二维 DP 算出 `dp[n][n]`，即 `s` 与 `reverse(s)` 的最长公共子序列长度。
- **第二步** 返回 `n - lps`。

****

## 26. bisect_left 和 bisect_right



上面输出揭示了 `bisect_left` 和 `bisect_right` 的核心区别：

- **`bisect_left(arr, k)`**
   返回在保持「有序」的前提下，**第一个不小于** `k` 的索引。
  - 因此，它等于 **`arr` 中小于 `k` 的元素个数**。
- **`bisect_right(arr, k)`**
   返回第一个**大于** `k` 的索引。
  - 因此，它等于 **`arr` 中小于等于 `k` 的元素个数**。

例如 `arr = [1,2,2,3,4,4,4,5]`：

| k    | bisect_left | bisect_right | `< k` 个数 | `≤ k` 个数 |
| ---- | ----------- | ------------ | ---------- | ---------- |
| 2    | 1           | 3            | 1          | 3          |
| 4    | 4           | 7            | 4          | 7          |

- **`count_lt`**（严格小于 `k`）在整块时用 `bisect_left`；
- **`count_leq`**（小于等于 `k`）在整块时用 `bisect_right`。

这样，你在 `count_lt_in_range`/`count_leq_in_range` 中调用它们，就能快速得到整块的计数。









## 27. MST和MBST

------

1. **什么是最小生成树 (MST)**
   - 在一个连通无向图里，找到一棵包含所有顶点、没有环的树，使得所有边权相加最小。
2. **什么是瓶颈生成树 (MBST)**
   - 把一棵生成树里最重的那条边记为“瓶颈”。MBST 就是在所有生成树里，**这条最重的边尽可能小**。
3. **为什么任意一棵 MST 也是 MBST**
   - 如果一棵树的“最重边”不是最小的，你可以换上一条更轻的边，既会让总权重降下去，也会让“最重边”变小。
   - 因为 MST 已经把 **总重量** 压到最低，它自然不会留有可以更轻的“最重边”，所以它的瓶颈也是最小的。
4. **常见简单结论**
   - **唯一性**：如果所有边权都不一样，那么 MST 只有一棵；相同权重时可能有多棵，但它们总重一样。
   - **交换思想**：任意一条没在树上的边，往树里加会形成环，你总可以把环里最重的边换出去，或减重或总重不变。
   - **路径最小边最大化**：在 MST 上，从 A 到 B 的路径，其中最小那条边，比任何其他从 A 到 B 的路径的最小边都要大。也就是说，MST 给你一条“最粗的最细管道”。
5. **举个小例子**
   - 图有 4 个点，边权分别是 1、2、3、4、5、6。MST 会选 1、2、3 这三条最轻的边，总重 6；它的“瓶颈”就是 3。
   - 任何其他生成树，如果想让“瓶颈”小于 3，必须用 1、2、*再选一条 ≤2* 的边，但除了 1、2、3 以外，没有更轻的边可用，所以这棵树也是 MBST。



------

## 28. 数值半群

> 给定一个正整数集合 $S = \langle L,L+1,\dots,R \rangle$，
>  定义：**无法被 $S$ 中元素表示出的正整数个数是多少？**

我们称这个集合 $S$ 生成的所有数叫**数值半群**（numerical semigroup）。

### 什么是 Apéry 集（Apéry Set）？

> 给定一个生成集合 $S$，我们关心它对某个整数 $m$ 的**最小可表示数**集合：
>
> Apm(S)={s∈S∣s≡r(modm), 0≤r<m, 且 s 是余数 r 的最小可表示值}\text{Ap}_m(S) = \{s \in S \mid s \equiv r \pmod m,~ 0 \le r < m,\text{ 且 } s \text{ 是余数 } r \text{ 的最小可表示值}\}
>
> 简单讲：**对每个余数 $r\in[0,m-1]$**，在 $S$ 中找出最小满足 $x \equiv r \pmod m$ 的数。

这个集合的大小就是 $m$ 个数，它们“最早覆盖”了所有模 $m$ 的余数。

### 为啥要用 Apéry 集？

Apéry 集提供了一种方法，从结构上描述整个数值半群「从哪开始完全覆盖所有正整数」——这个结构跟“**无法表示的数的个数**”是直接相关的。

根据数值半群的研究：

> **缺失数个数（也叫 genus）** 满足：
>
> genus(S)=∑x∈Apm(S)x−rem(x,m)m−m−12\text{genus}(S) = \sum_{x \in \text{Ap}_m(S)} \frac{x - \mathrm{rem}(x,m)}{m} - \frac{m-1}{2}

这个公式看起来复杂，但对于我们特别关心的情况：

> 当 $S = \langle L, L+1, ..., R \rangle$，设 $d = R - L$，设 $m = L$，
>  就可以用一个非常经典的等价表达式：

### Apéry 集公式（本题适用版本）

设：

- $L$：区间左端点

- $d = R - L$：区间长度

- $m = L - 1$：我们需要覆盖的非零余数个数

- 把 $m$ 除以 $d$：

  $m = q \cdot d + r,\quad 0 \le r < d$

那么：

> $\boxed{\text{缺失个数} = \frac{d\cdot q \cdot (q+1)}{2} + r \cdot (q+1)}$

这是由 Apéry 集分层结构直接推导出来的闭式。

### 分层法理解：

我们每次能“铺开”一层：比如选择一堆数，使得能凑出余数 $r\in[1,d]$，下一次就可以凑出 $r+d$，再下一次 $r+2d$… 以此类推。

- 每一层最多能“覆盖” $d$ 个新的余数类。
- 我们总共有 $m = L - 1$ 个余数类。
- 所以我们需要：
  - $q$ 层：每层 $d$ 个，共 $q\cdot d$
  - 再加 1 层：最后剩下 $r$ 个。

这就构成了：

- 第 0 层：$d$ 个余数，距离约为 $1\cdot L$
- 第 1 层：$d$ 个余数，距离约为 $2\cdot L$
- …
- 第 $q-1$ 层：$d$ 个余数
- 第 $q$ 层：$r$ 个余数

每个余数类 $r$ 的最小可表示值约为 $L \cdot \text{层号} + (\text{某个偏移})$
 因此，无法表示的数就是：

> 对每个余数类 $r$，所有小于 $\mathrm{dist}[r]$ 的数都不行 ⇒ 总体个数为：

$\sum_{r=1}^{L-1} \Bigl\lfloor\frac{\mathrm{dist}[r]}{L}\Bigr\rfloor \quad\Rightarrow\quad \boxed{d\cdot\frac{q(q+1)}2 + r\cdot(q+1)}$



------

### 总结

| 项         | 含义                                                        |
| ---------- | ----------------------------------------------------------- |
| Apéry 集   | 每个余数类的最小可表示数                                    |
| Apéry 分层 | 把余数类按 d 分成 q 层，每层向上累加                        |
| genus      | 无法表示的正整数个数                                        |
| 经典公式   | $\boxed{\frac{d q (q+1)}{2} + r(q+1)}$，其中 $L-1 = qd + r$ |

****



好！你这个问题问得特别关键：“完美匹配数”到底是什么？为啥突然就跳出来了这个公式？

下面我们从零开始、用你能理解的方式好好讲清楚这个概念，并解释它怎么和我们题目中的“路径配对”挂上钩的。

------

## 29. 完美匹配（Perfect Matching）

> 在组合数学中，**完美匹配**指的是：把一个偶数个元素的集合，**两两配对**，且每个元素**恰好出现在一对中**。

举个例子，假设你有 4 条边 $[e_1, e_2, e_3, e_4]$，你想把它们两两分成配对：

- 一种方案是 $(e_1,e_2), (e_3,e_4)$
- 另一种是 $(e_1,e_3), (e_2,e_4)$
- 还有 $(e_1,e_4), (e_2,e_3)$

这就是**完美匹配的所有方案**。

------

### 完美匹配数公式（经典结论）

设有 $2n$ 个元素，完美匹配的总数是多少？

> $\boxed{\text{完美匹配数} = \frac{(2n)!}{n! \cdot 2^n}}$

这个式子你可以这样理解：

- $(2n)!$：所有排列方法
- 除以 $n!$：因为每一对之间无序（交换两对不算新方案）
- 除以 $2^n$：因为每一对内部也无序（交换 $a,b$ 和 $b,a$ 是同一个）

------

### 我们题目中怎么用到的？

你想想，一个树上的节点，比如度数为 4，连接了 4 条边：
 你要构造路径集合，使得这些边中的每一条被恰好覆盖一次。
 为了做到这一点，这些边要么：

- 配成一对一对的：变成路径的“中间段”
- 留下一条边：当作路径的“端点”

也就是说，你需要把这些边**分组配对**！

因此，每个节点你要问的问题就是：

> “我有 $d$ 条边，能有多少种方式把它们两两配对（留 0 或 1 条边）？”

这就是**完美匹配计数问题**，正是用上面公式：

$\boxed{ g(d) = \frac{d!}{2^{\lfloor d/2 \rfloor} \cdot \lfloor d/2 \rfloor!} }$

- 偶数度：全部配成 $m$ 对
- 奇数度：留下 1 条，剩下的 $2m$ 条配成 $m$ 对

